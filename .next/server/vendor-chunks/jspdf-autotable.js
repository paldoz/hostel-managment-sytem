/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jspdf-autotable";
exports.ids = ["vendor-chunks/jspdf-autotable"];
exports.modules = {

/***/ "(ssr)/./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*!\n * \n *               jsPDF AutoTable plugin v3.8.4\n *\n *               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable\n *               Licensed under the MIT License.\n *               http://opensource.org/licenses/mit-license\n *\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(function webpackLoadOptionalExternalModule() {\n        try {\n            return __webpack_require__(/*! jspdf */ \"(ssr)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n        } catch (e) {}\n    }());\n    else { var i, a; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof this !== \"undefined\" ? this :  false ? 0 : typeof self !== \"undefined\" ? self : global, function(__WEBPACK_EXTERNAL_MODULE__964__) {\n    return /******/ function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = {\n            /***/ 172: /***/ function(__unused_webpack_module, exports1) {\n                var __extends = this && this.__extends || function() {\n                    var extendStatics = function(d, b) {\n                        extendStatics = Object.setPrototypeOf || ({\n                            __proto__: []\n                        }) instanceof Array && function(d, b) {\n                            d.__proto__ = b;\n                        } || function(d, b) {\n                            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n                        };\n                        return extendStatics(d, b);\n                    };\n                    return function(d, b) {\n                        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                        extendStatics(d, b);\n                        function __() {\n                            this.constructor = d;\n                        }\n                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                    };\n                }();\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.CellHookData = exports1.HookData = void 0;\n                var HookData = /** @class */ function() {\n                    function HookData(doc, table, cursor) {\n                        this.table = table;\n                        this.pageNumber = table.pageNumber;\n                        this.pageCount = this.pageNumber;\n                        this.settings = table.settings;\n                        this.cursor = cursor;\n                        this.doc = doc.getDocument();\n                    }\n                    return HookData;\n                }();\n                exports1.HookData = HookData;\n                var CellHookData = /** @class */ function(_super) {\n                    __extends(CellHookData, _super);\n                    function CellHookData(doc, table, cell, row, column, cursor) {\n                        var _this = _super.call(this, doc, table, cursor) || this;\n                        _this.cell = cell;\n                        _this.row = row;\n                        _this.column = column;\n                        _this.section = row.section;\n                        return _this;\n                    }\n                    return CellHookData;\n                }(HookData);\n                exports1.CellHookData = CellHookData;\n            /***/ },\n            /***/ 340: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_3996__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var htmlParser_1 = __nested_webpack_require_3996__(4);\n                var autoTableText_1 = __nested_webpack_require_3996__(136);\n                var documentHandler_1 = __nested_webpack_require_3996__(744);\n                var inputParser_1 = __nested_webpack_require_3996__(776);\n                var tableDrawer_1 = __nested_webpack_require_3996__(664);\n                var tableCalculator_1 = __nested_webpack_require_3996__(972);\n                function default_1(jsPDF) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    jsPDF.API.autoTable = function() {\n                        var args = [];\n                        for(var _i = 0; _i < arguments.length; _i++){\n                            args[_i] = arguments[_i];\n                        }\n                        var options;\n                        if (args.length === 1) {\n                            options = args[0];\n                        } else {\n                            console.error(\"Use of deprecated autoTable initiation\");\n                            options = args[2] || {};\n                            options.columns = args[0];\n                            options.body = args[1];\n                        }\n                        var input = (0, inputParser_1.parseInput)(this, options);\n                        var table = (0, tableCalculator_1.createTable)(this, input);\n                        (0, tableDrawer_1.drawTable)(this, table);\n                        return this;\n                    };\n                    // Assign false to enable `doc.lastAutoTable.finalY || 40` sugar\n                    jsPDF.API.lastAutoTable = false;\n                    jsPDF.API.previousAutoTable = false; // deprecated in v3\n                    jsPDF.API.autoTable.previous = false; // deprecated in v3\n                    jsPDF.API.autoTableText = function(text, x, y, styles) {\n                        (0, autoTableText_1.default)(text, x, y, styles, this);\n                    };\n                    jsPDF.API.autoTableSetDefaults = function(defaults) {\n                        documentHandler_1.DocHandler.setDefaults(defaults, this);\n                        return this;\n                    };\n                    jsPDF.autoTableSetDefaults = function(defaults, doc) {\n                        documentHandler_1.DocHandler.setDefaults(defaults, doc);\n                    };\n                    jsPDF.API.autoTableHtmlToJson = function(tableElem, includeHiddenElements) {\n                        var _a;\n                        if (includeHiddenElements === void 0) {\n                            includeHiddenElements = false;\n                        }\n                        if (true) {\n                            console.error(\"Cannot run autoTableHtmlToJson in non browser environment\");\n                            return null;\n                        }\n                        var doc = new documentHandler_1.DocHandler(this);\n                        var _b = (0, htmlParser_1.parseHtml)(doc, tableElem, window, includeHiddenElements, false), head = _b.head, body = _b.body;\n                        var columns = ((_a = head[0]) === null || _a === void 0 ? void 0 : _a.map(function(c) {\n                            return c.content;\n                        })) || [];\n                        return {\n                            columns: columns,\n                            rows: body,\n                            data: body\n                        };\n                    };\n                    /**\n     * @deprecated\n     */ jsPDF.API.autoTableEndPosY = function() {\n                        console.error(\"Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.\");\n                        var prev = this.lastAutoTable;\n                        if (prev && prev.finalY) {\n                            return prev.finalY;\n                        } else {\n                            return 0;\n                        }\n                    };\n                    /**\n     * @deprecated\n     */ jsPDF.API.autoTableAddPageContent = function(hook) {\n                        console.error(\"Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead.\");\n                        if (!jsPDF.API.autoTable.globalDefaults) {\n                            jsPDF.API.autoTable.globalDefaults = {};\n                        }\n                        jsPDF.API.autoTable.globalDefaults.addPageContent = hook;\n                        return this;\n                    };\n                    /**\n     * @deprecated\n     */ jsPDF.API.autoTableAddPage = function() {\n                        console.error(\"Use of deprecated function: autoTableAddPage. Use doc.addPage()\");\n                        this.addPage();\n                        return this;\n                    };\n                }\n                exports1[\"default\"] = default_1;\n            /***/ },\n            /***/ 136: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                /**\n * Improved text function with halign and valign support\n * Inspiration from: http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113\n */ function default_1(text, x, y, styles, doc) {\n                    styles = styles || {};\n                    var PHYSICAL_LINE_HEIGHT = 1.15;\n                    var k = doc.internal.scaleFactor;\n                    var fontSize = doc.internal.getFontSize() / k;\n                    var lineHeightFactor = doc.getLineHeightFactor ? doc.getLineHeightFactor() : PHYSICAL_LINE_HEIGHT;\n                    var lineHeight = fontSize * lineHeightFactor;\n                    var splitRegex = /\\r\\n|\\r|\\n/g;\n                    var splitText = \"\";\n                    var lineCount = 1;\n                    if (styles.valign === \"middle\" || styles.valign === \"bottom\" || styles.halign === \"center\" || styles.halign === \"right\") {\n                        splitText = typeof text === \"string\" ? text.split(splitRegex) : text;\n                        lineCount = splitText.length || 1;\n                    }\n                    // Align the top\n                    y += fontSize * (2 - PHYSICAL_LINE_HEIGHT);\n                    if (styles.valign === \"middle\") y -= lineCount / 2 * lineHeight;\n                    else if (styles.valign === \"bottom\") y -= lineCount * lineHeight;\n                    if (styles.halign === \"center\" || styles.halign === \"right\") {\n                        var alignSize = fontSize;\n                        if (styles.halign === \"center\") alignSize *= 0.5;\n                        if (splitText && lineCount >= 1) {\n                            for(var iLine = 0; iLine < splitText.length; iLine++){\n                                doc.text(splitText[iLine], x - doc.getStringUnitWidth(splitText[iLine]) * alignSize, y);\n                                y += lineHeight;\n                            }\n                            return doc;\n                        }\n                        x -= doc.getStringUnitWidth(text) * alignSize;\n                    }\n                    if (styles.halign === \"justify\") {\n                        doc.text(text, x, y, {\n                            maxWidth: styles.maxWidth || 100,\n                            align: \"justify\"\n                        });\n                    } else {\n                        doc.text(text, x, y);\n                    }\n                    return doc;\n                }\n                exports1[\"default\"] = default_1;\n            /***/ },\n            /***/ 420: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.getPageAvailableWidth = exports1.parseSpacing = exports1.getFillStyle = exports1.addTableBorder = exports1.getStringWidth = void 0;\n                function getStringWidth(text, styles, doc) {\n                    doc.applyStyles(styles, true);\n                    var textArr = Array.isArray(text) ? text : [\n                        text\n                    ];\n                    var widestLineWidth = textArr.map(function(text) {\n                        return doc.getTextWidth(text);\n                    }).reduce(function(a, b) {\n                        return Math.max(a, b);\n                    }, 0);\n                    return widestLineWidth;\n                }\n                exports1.getStringWidth = getStringWidth;\n                function addTableBorder(doc, table, startPos, cursor) {\n                    var lineWidth = table.settings.tableLineWidth;\n                    var lineColor = table.settings.tableLineColor;\n                    doc.applyStyles({\n                        lineWidth: lineWidth,\n                        lineColor: lineColor\n                    });\n                    var fillStyle = getFillStyle(lineWidth, false);\n                    if (fillStyle) {\n                        doc.rect(startPos.x, startPos.y, table.getWidth(doc.pageSize().width), cursor.y - startPos.y, fillStyle);\n                    }\n                }\n                exports1.addTableBorder = addTableBorder;\n                function getFillStyle(lineWidth, fillColor) {\n                    var drawLine = lineWidth > 0;\n                    var drawBackground = fillColor || fillColor === 0;\n                    if (drawLine && drawBackground) {\n                        return \"DF\"; // Fill then stroke\n                    } else if (drawLine) {\n                        return \"S\"; // Only stroke (transparent background)\n                    } else if (drawBackground) {\n                        return \"F\"; // Only fill, no stroke\n                    } else {\n                        return null;\n                    }\n                }\n                exports1.getFillStyle = getFillStyle;\n                function parseSpacing(value, defaultValue) {\n                    var _a, _b, _c, _d;\n                    value = value || defaultValue;\n                    if (Array.isArray(value)) {\n                        if (value.length >= 4) {\n                            return {\n                                top: value[0],\n                                right: value[1],\n                                bottom: value[2],\n                                left: value[3]\n                            };\n                        } else if (value.length === 3) {\n                            return {\n                                top: value[0],\n                                right: value[1],\n                                bottom: value[2],\n                                left: value[1]\n                            };\n                        } else if (value.length === 2) {\n                            return {\n                                top: value[0],\n                                right: value[1],\n                                bottom: value[0],\n                                left: value[1]\n                            };\n                        } else if (value.length === 1) {\n                            value = value[0];\n                        } else {\n                            value = defaultValue;\n                        }\n                    }\n                    if (typeof value === \"object\") {\n                        if (typeof value.vertical === \"number\") {\n                            value.top = value.vertical;\n                            value.bottom = value.vertical;\n                        }\n                        if (typeof value.horizontal === \"number\") {\n                            value.right = value.horizontal;\n                            value.left = value.horizontal;\n                        }\n                        return {\n                            left: (_a = value.left) !== null && _a !== void 0 ? _a : defaultValue,\n                            top: (_b = value.top) !== null && _b !== void 0 ? _b : defaultValue,\n                            right: (_c = value.right) !== null && _c !== void 0 ? _c : defaultValue,\n                            bottom: (_d = value.bottom) !== null && _d !== void 0 ? _d : defaultValue\n                        };\n                    }\n                    if (typeof value !== \"number\") {\n                        value = defaultValue;\n                    }\n                    return {\n                        top: value,\n                        right: value,\n                        bottom: value,\n                        left: value\n                    };\n                }\n                exports1.parseSpacing = parseSpacing;\n                function getPageAvailableWidth(doc, table) {\n                    var margins = parseSpacing(table.settings.margin, 0);\n                    return doc.pageSize().width - (margins.left + margins.right);\n                }\n                exports1.getPageAvailableWidth = getPageAvailableWidth;\n            /***/ },\n            /***/ 796: /***/ function(__unused_webpack_module, exports1) {\n                var __extends = this && this.__extends || function() {\n                    var extendStatics = function(d, b) {\n                        extendStatics = Object.setPrototypeOf || ({\n                            __proto__: []\n                        }) instanceof Array && function(d, b) {\n                            d.__proto__ = b;\n                        } || function(d, b) {\n                            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n                        };\n                        return extendStatics(d, b);\n                    };\n                    return function(d, b) {\n                        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                        extendStatics(d, b);\n                        function __() {\n                            this.constructor = d;\n                        }\n                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                    };\n                }();\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.getTheme = exports1.defaultStyles = exports1.HtmlRowInput = void 0;\n                var HtmlRowInput = /** @class */ function(_super) {\n                    __extends(HtmlRowInput, _super);\n                    function HtmlRowInput(element) {\n                        var _this = _super.call(this) || this;\n                        _this._element = element;\n                        return _this;\n                    }\n                    return HtmlRowInput;\n                }(Array);\n                exports1.HtmlRowInput = HtmlRowInput;\n                // Base style for all themes\n                function defaultStyles(scaleFactor) {\n                    return {\n                        font: \"helvetica\",\n                        fontStyle: \"normal\",\n                        overflow: \"linebreak\",\n                        fillColor: false,\n                        textColor: 20,\n                        halign: \"left\",\n                        valign: \"top\",\n                        fontSize: 10,\n                        cellPadding: 5 / scaleFactor,\n                        lineColor: 200,\n                        lineWidth: 0,\n                        cellWidth: \"auto\",\n                        minCellHeight: 0,\n                        minCellWidth: 0\n                    };\n                }\n                exports1.defaultStyles = defaultStyles;\n                function getTheme(name) {\n                    var themes = {\n                        striped: {\n                            table: {\n                                fillColor: 255,\n                                textColor: 80,\n                                fontStyle: \"normal\"\n                            },\n                            head: {\n                                textColor: 255,\n                                fillColor: [\n                                    41,\n                                    128,\n                                    185\n                                ],\n                                fontStyle: \"bold\"\n                            },\n                            body: {},\n                            foot: {\n                                textColor: 255,\n                                fillColor: [\n                                    41,\n                                    128,\n                                    185\n                                ],\n                                fontStyle: \"bold\"\n                            },\n                            alternateRow: {\n                                fillColor: 245\n                            }\n                        },\n                        grid: {\n                            table: {\n                                fillColor: 255,\n                                textColor: 80,\n                                fontStyle: \"normal\",\n                                lineWidth: 0.1\n                            },\n                            head: {\n                                textColor: 255,\n                                fillColor: [\n                                    26,\n                                    188,\n                                    156\n                                ],\n                                fontStyle: \"bold\",\n                                lineWidth: 0\n                            },\n                            body: {},\n                            foot: {\n                                textColor: 255,\n                                fillColor: [\n                                    26,\n                                    188,\n                                    156\n                                ],\n                                fontStyle: \"bold\",\n                                lineWidth: 0\n                            },\n                            alternateRow: {}\n                        },\n                        plain: {\n                            head: {\n                                fontStyle: \"bold\"\n                            },\n                            foot: {\n                                fontStyle: \"bold\"\n                            }\n                        }\n                    };\n                    return themes[name];\n                }\n                exports1.getTheme = getTheme;\n            /***/ },\n            /***/ 903: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_22823__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.parseCss = void 0;\n                // Limitations\n                // - No support for border spacing\n                // - No support for transparency\n                var common_1 = __nested_webpack_require_22823__(420);\n                function parseCss(supportedFonts, element, scaleFactor, style, window1) {\n                    var result = {};\n                    var pxScaleFactor = 96 / 72;\n                    var backgroundColor = parseColor(element, function(elem) {\n                        return window1.getComputedStyle(elem)[\"backgroundColor\"];\n                    });\n                    if (backgroundColor != null) result.fillColor = backgroundColor;\n                    var textColor = parseColor(element, function(elem) {\n                        return window1.getComputedStyle(elem)[\"color\"];\n                    });\n                    if (textColor != null) result.textColor = textColor;\n                    var padding = parsePadding(style, scaleFactor);\n                    if (padding) result.cellPadding = padding;\n                    var borderColorSide = \"borderTopColor\";\n                    var finalScaleFactor = pxScaleFactor * scaleFactor;\n                    var btw = style.borderTopWidth;\n                    if (style.borderBottomWidth === btw && style.borderRightWidth === btw && style.borderLeftWidth === btw) {\n                        var borderWidth = (parseFloat(btw) || 0) / finalScaleFactor;\n                        if (borderWidth) result.lineWidth = borderWidth;\n                    } else {\n                        result.lineWidth = {\n                            top: (parseFloat(style.borderTopWidth) || 0) / finalScaleFactor,\n                            right: (parseFloat(style.borderRightWidth) || 0) / finalScaleFactor,\n                            bottom: (parseFloat(style.borderBottomWidth) || 0) / finalScaleFactor,\n                            left: (parseFloat(style.borderLeftWidth) || 0) / finalScaleFactor\n                        };\n                        // Choose border color of first available side\n                        // could be improved by supporting object as lineColor\n                        if (!result.lineWidth.top) {\n                            if (result.lineWidth.right) {\n                                borderColorSide = \"borderRightColor\";\n                            } else if (result.lineWidth.bottom) {\n                                borderColorSide = \"borderBottomColor\";\n                            } else if (result.lineWidth.left) {\n                                borderColorSide = \"borderLeftColor\";\n                            }\n                        }\n                    }\n                    var borderColor = parseColor(element, function(elem) {\n                        return window1.getComputedStyle(elem)[borderColorSide];\n                    });\n                    if (borderColor != null) result.lineColor = borderColor;\n                    var accepted = [\n                        \"left\",\n                        \"right\",\n                        \"center\",\n                        \"justify\"\n                    ];\n                    if (accepted.indexOf(style.textAlign) !== -1) {\n                        result.halign = style.textAlign;\n                    }\n                    accepted = [\n                        \"middle\",\n                        \"bottom\",\n                        \"top\"\n                    ];\n                    if (accepted.indexOf(style.verticalAlign) !== -1) {\n                        result.valign = style.verticalAlign;\n                    }\n                    var res = parseInt(style.fontSize || \"\");\n                    if (!isNaN(res)) result.fontSize = res / pxScaleFactor;\n                    var fontStyle = parseFontStyle(style);\n                    if (fontStyle) result.fontStyle = fontStyle;\n                    var font = (style.fontFamily || \"\").toLowerCase();\n                    if (supportedFonts.indexOf(font) !== -1) {\n                        result.font = font;\n                    }\n                    return result;\n                }\n                exports1.parseCss = parseCss;\n                function parseFontStyle(style) {\n                    var res = \"\";\n                    if (style.fontWeight === \"bold\" || style.fontWeight === \"bolder\" || parseInt(style.fontWeight) >= 700) {\n                        res = \"bold\";\n                    }\n                    if (style.fontStyle === \"italic\" || style.fontStyle === \"oblique\") {\n                        res += \"italic\";\n                    }\n                    return res;\n                }\n                function parseColor(element, styleGetter) {\n                    var cssColor = realColor(element, styleGetter);\n                    if (!cssColor) return null;\n                    var rgba = cssColor.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d*))?\\)$/);\n                    if (!rgba || !Array.isArray(rgba)) {\n                        return null;\n                    }\n                    var color = [\n                        parseInt(rgba[1]),\n                        parseInt(rgba[2]),\n                        parseInt(rgba[3])\n                    ];\n                    var alpha = parseInt(rgba[4]);\n                    if (alpha === 0 || isNaN(color[0]) || isNaN(color[1]) || isNaN(color[2])) {\n                        return null;\n                    }\n                    return color;\n                }\n                function realColor(elem, styleGetter) {\n                    var bg = styleGetter(elem);\n                    if (bg === \"rgba(0, 0, 0, 0)\" || bg === \"transparent\" || bg === \"initial\" || bg === \"inherit\") {\n                        if (elem.parentElement == null) {\n                            return null;\n                        }\n                        return realColor(elem.parentElement, styleGetter);\n                    } else {\n                        return bg;\n                    }\n                }\n                function parsePadding(style, scaleFactor) {\n                    var val = [\n                        style.paddingTop,\n                        style.paddingRight,\n                        style.paddingBottom,\n                        style.paddingLeft\n                    ];\n                    var pxScaleFactor = 96 / (72 / scaleFactor);\n                    var linePadding = (parseInt(style.lineHeight) - parseInt(style.fontSize)) / scaleFactor / 2;\n                    var inputPadding = val.map(function(n) {\n                        return parseInt(n || \"0\") / pxScaleFactor;\n                    });\n                    var padding = (0, common_1.parseSpacing)(inputPadding, 0);\n                    if (linePadding > padding.top) {\n                        padding.top = linePadding;\n                    }\n                    if (linePadding > padding.bottom) {\n                        padding.bottom = linePadding;\n                    }\n                    return padding;\n                }\n            /***/ },\n            /***/ 744: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.DocHandler = void 0;\n                var globalDefaults = {};\n                var DocHandler = /** @class */ function() {\n                    function DocHandler(jsPDFDocument) {\n                        this.jsPDFDocument = jsPDFDocument;\n                        this.userStyles = {\n                            // Black for versions of jspdf without getTextColor\n                            textColor: jsPDFDocument.getTextColor ? this.jsPDFDocument.getTextColor() : 0,\n                            fontSize: jsPDFDocument.internal.getFontSize(),\n                            fontStyle: jsPDFDocument.internal.getFont().fontStyle,\n                            font: jsPDFDocument.internal.getFont().fontName,\n                            // 0 for versions of jspdf without getLineWidth\n                            lineWidth: jsPDFDocument.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,\n                            // Black for versions of jspdf without getDrawColor\n                            lineColor: jsPDFDocument.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0\n                        };\n                    }\n                    DocHandler.setDefaults = function(defaults, doc) {\n                        if (doc === void 0) {\n                            doc = null;\n                        }\n                        if (doc) {\n                            doc.__autoTableDocumentDefaults = defaults;\n                        } else {\n                            globalDefaults = defaults;\n                        }\n                    };\n                    DocHandler.unifyColor = function(c) {\n                        if (Array.isArray(c)) {\n                            return c;\n                        } else if (typeof c === \"number\") {\n                            return [\n                                c,\n                                c,\n                                c\n                            ];\n                        } else if (typeof c === \"string\") {\n                            return [\n                                c\n                            ];\n                        } else {\n                            return null;\n                        }\n                    };\n                    DocHandler.prototype.applyStyles = function(styles, fontOnly) {\n                        // Font style needs to be applied before font\n                        // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/632\n                        var _a, _b, _c;\n                        if (fontOnly === void 0) {\n                            fontOnly = false;\n                        }\n                        if (styles.fontStyle) this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(styles.fontStyle);\n                        var _d = this.jsPDFDocument.internal.getFont(), fontStyle = _d.fontStyle, fontName = _d.fontName;\n                        if (styles.font) fontName = styles.font;\n                        if (styles.fontStyle) {\n                            fontStyle = styles.fontStyle;\n                            var availableFontStyles = this.getFontList()[fontName];\n                            if (availableFontStyles && availableFontStyles.indexOf(fontStyle) === -1) {\n                                // Common issue was that the default bold in headers\n                                // made custom fonts not work. For example:\n                                // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/653\n                                this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(availableFontStyles[0]);\n                                fontStyle = availableFontStyles[0];\n                            }\n                        }\n                        this.jsPDFDocument.setFont(fontName, fontStyle);\n                        if (styles.fontSize) this.jsPDFDocument.setFontSize(styles.fontSize);\n                        if (fontOnly) {\n                            return; // Performance improvement\n                        }\n                        var color = DocHandler.unifyColor(styles.fillColor);\n                        if (color) (_a = this.jsPDFDocument).setFillColor.apply(_a, color);\n                        color = DocHandler.unifyColor(styles.textColor);\n                        if (color) (_b = this.jsPDFDocument).setTextColor.apply(_b, color);\n                        color = DocHandler.unifyColor(styles.lineColor);\n                        if (color) (_c = this.jsPDFDocument).setDrawColor.apply(_c, color);\n                        if (typeof styles.lineWidth === \"number\") {\n                            this.jsPDFDocument.setLineWidth(styles.lineWidth);\n                        }\n                    };\n                    DocHandler.prototype.splitTextToSize = function(text, size, opts) {\n                        return this.jsPDFDocument.splitTextToSize(text, size, opts);\n                    };\n                    /**\n     * Adds a rectangle to the PDF\n     * @param x Coordinate (in units declared at inception of PDF document) against left edge of the page\n     * @param y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n     * @param width Width (in units declared at inception of PDF document)\n     * @param height Height (in units declared at inception of PDF document)\n     * @param fillStyle A string specifying the painting style or null. Valid styles include: 'S' [default] - stroke, 'F' - fill, and 'DF' (or 'FD') - fill then stroke.\n     */ DocHandler.prototype.rect = function(x, y, width, height, fillStyle) {\n                        // null is excluded from fillStyle possible values because it isn't needed\n                        // and is prone to bugs as it's used to postpone setting the style\n                        // https://rawgit.com/MrRio/jsPDF/master/docs/jsPDF.html#rect\n                        return this.jsPDFDocument.rect(x, y, width, height, fillStyle);\n                    };\n                    DocHandler.prototype.getLastAutoTable = function() {\n                        return this.jsPDFDocument.lastAutoTable || null;\n                    };\n                    DocHandler.prototype.getTextWidth = function(text) {\n                        return this.jsPDFDocument.getTextWidth(text);\n                    };\n                    DocHandler.prototype.getDocument = function() {\n                        return this.jsPDFDocument;\n                    };\n                    DocHandler.prototype.setPage = function(page) {\n                        this.jsPDFDocument.setPage(page);\n                    };\n                    DocHandler.prototype.addPage = function() {\n                        return this.jsPDFDocument.addPage();\n                    };\n                    DocHandler.prototype.getFontList = function() {\n                        return this.jsPDFDocument.getFontList();\n                    };\n                    DocHandler.prototype.getGlobalOptions = function() {\n                        return globalDefaults || {};\n                    };\n                    DocHandler.prototype.getDocumentOptions = function() {\n                        return this.jsPDFDocument.__autoTableDocumentDefaults || {};\n                    };\n                    DocHandler.prototype.pageSize = function() {\n                        var pageSize = this.jsPDFDocument.internal.pageSize;\n                        // JSPDF 1.4 uses get functions instead of properties on pageSize\n                        if (pageSize.width == null) {\n                            pageSize = {\n                                width: pageSize.getWidth(),\n                                height: pageSize.getHeight()\n                            };\n                        }\n                        return pageSize;\n                    };\n                    DocHandler.prototype.scaleFactor = function() {\n                        return this.jsPDFDocument.internal.scaleFactor;\n                    };\n                    DocHandler.prototype.getLineHeightFactor = function() {\n                        var doc = this.jsPDFDocument;\n                        return doc.getLineHeightFactor ? doc.getLineHeightFactor() : 1.15;\n                    };\n                    DocHandler.prototype.getLineHeight = function(fontSize) {\n                        return fontSize / this.scaleFactor() * this.getLineHeightFactor();\n                    };\n                    DocHandler.prototype.pageNumber = function() {\n                        var pageInfo = this.jsPDFDocument.internal.getCurrentPageInfo();\n                        if (!pageInfo) {\n                            // Only recent versions of jspdf has pageInfo\n                            return this.jsPDFDocument.internal.getNumberOfPages();\n                        }\n                        return pageInfo.pageNumber;\n                    };\n                    return DocHandler;\n                }();\n                exports1.DocHandler = DocHandler;\n            /***/ },\n            /***/ 4: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_39259__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.parseHtml = void 0;\n                var cssParser_1 = __nested_webpack_require_39259__(903);\n                var config_1 = __nested_webpack_require_39259__(796);\n                function parseHtml(doc, input, window1, includeHiddenHtml, useCss) {\n                    var _a, _b;\n                    if (includeHiddenHtml === void 0) {\n                        includeHiddenHtml = false;\n                    }\n                    if (useCss === void 0) {\n                        useCss = false;\n                    }\n                    var tableElement;\n                    if (typeof input === \"string\") {\n                        tableElement = window1.document.querySelector(input);\n                    } else {\n                        tableElement = input;\n                    }\n                    var supportedFonts = Object.keys(doc.getFontList());\n                    var scaleFactor = doc.scaleFactor();\n                    var head = [], body = [], foot = [];\n                    if (!tableElement) {\n                        console.error(\"Html table could not be found with input: \", input);\n                        return {\n                            head: head,\n                            body: body,\n                            foot: foot\n                        };\n                    }\n                    for(var i = 0; i < tableElement.rows.length; i++){\n                        var element = tableElement.rows[i];\n                        var tagName = (_b = (_a = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n                        var row = parseRowContent(supportedFonts, scaleFactor, window1, element, includeHiddenHtml, useCss);\n                        if (!row) continue;\n                        if (tagName === \"thead\") {\n                            head.push(row);\n                        } else if (tagName === \"tfoot\") {\n                            foot.push(row);\n                        } else {\n                            // Add to body both if parent is tbody or table\n                            body.push(row);\n                        }\n                    }\n                    return {\n                        head: head,\n                        body: body,\n                        foot: foot\n                    };\n                }\n                exports1.parseHtml = parseHtml;\n                function parseRowContent(supportedFonts, scaleFactor, window1, row, includeHidden, useCss) {\n                    var resultRow = new config_1.HtmlRowInput(row);\n                    for(var i = 0; i < row.cells.length; i++){\n                        var cell = row.cells[i];\n                        var style_1 = window1.getComputedStyle(cell);\n                        if (includeHidden || style_1.display !== \"none\") {\n                            var cellStyles = void 0;\n                            if (useCss) {\n                                cellStyles = (0, cssParser_1.parseCss)(supportedFonts, cell, scaleFactor, style_1, window1);\n                            }\n                            resultRow.push({\n                                rowSpan: cell.rowSpan,\n                                colSpan: cell.colSpan,\n                                styles: cellStyles,\n                                _element: cell,\n                                content: parseCellContent(cell)\n                            });\n                        }\n                    }\n                    var style = window1.getComputedStyle(row);\n                    if (resultRow.length > 0 && (includeHidden || style.display !== \"none\")) {\n                        return resultRow;\n                    }\n                }\n                function parseCellContent(orgCell) {\n                    // Work on cloned node to make sure no changes are applied to html table\n                    var cell = orgCell.cloneNode(true);\n                    // Remove extra space and line breaks in markup to make it more similar to\n                    // what would be shown in html\n                    cell.innerHTML = cell.innerHTML.replace(/\\n/g, \"\").replace(/ +/g, \" \");\n                    // Preserve <br> tags as line breaks in the pdf\n                    cell.innerHTML = cell.innerHTML.split(/<br.*?>/) //start with '<br' and ends with '>'.\n                    .map(function(part) {\n                        return part.trim();\n                    }).join(\"\\n\");\n                    // innerText for ie\n                    return cell.innerText || cell.textContent || \"\";\n                }\n            /***/ },\n            /***/ 776: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_44130__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.parseInput = void 0;\n                var htmlParser_1 = __nested_webpack_require_44130__(4);\n                var polyfills_1 = __nested_webpack_require_44130__(356);\n                var common_1 = __nested_webpack_require_44130__(420);\n                var documentHandler_1 = __nested_webpack_require_44130__(744);\n                var inputValidator_1 = __nested_webpack_require_44130__(792);\n                function parseInput(d, current) {\n                    var doc = new documentHandler_1.DocHandler(d);\n                    var document = doc.getDocumentOptions();\n                    var global1 = doc.getGlobalOptions();\n                    (0, inputValidator_1.default)(doc, global1, document, current);\n                    var options = (0, polyfills_1.assign)({}, global1, document, current);\n                    var win;\n                    if (false) {}\n                    var styles = parseStyles(global1, document, current);\n                    var hooks = parseHooks(global1, document, current);\n                    var settings = parseSettings(doc, options);\n                    var content = parseContent(doc, options, win);\n                    return {\n                        id: current.tableId,\n                        content: content,\n                        hooks: hooks,\n                        styles: styles,\n                        settings: settings\n                    };\n                }\n                exports1.parseInput = parseInput;\n                function parseStyles(gInput, dInput, cInput) {\n                    var styleOptions = {\n                        styles: {},\n                        headStyles: {},\n                        bodyStyles: {},\n                        footStyles: {},\n                        alternateRowStyles: {},\n                        columnStyles: {}\n                    };\n                    var _loop_1 = function(prop) {\n                        if (prop === \"columnStyles\") {\n                            var global_1 = gInput[prop];\n                            var document_1 = dInput[prop];\n                            var current = cInput[prop];\n                            styleOptions.columnStyles = (0, polyfills_1.assign)({}, global_1, document_1, current);\n                        } else {\n                            var allOptions = [\n                                gInput,\n                                dInput,\n                                cInput\n                            ];\n                            var styles = allOptions.map(function(opts) {\n                                return opts[prop] || {};\n                            });\n                            styleOptions[prop] = (0, polyfills_1.assign)({}, styles[0], styles[1], styles[2]);\n                        }\n                    };\n                    for(var _i = 0, _a = Object.keys(styleOptions); _i < _a.length; _i++){\n                        var prop = _a[_i];\n                        _loop_1(prop);\n                    }\n                    return styleOptions;\n                }\n                function parseHooks(global1, document, current) {\n                    var allOptions = [\n                        global1,\n                        document,\n                        current\n                    ];\n                    var result = {\n                        didParseCell: [],\n                        willDrawCell: [],\n                        didDrawCell: [],\n                        willDrawPage: [],\n                        didDrawPage: []\n                    };\n                    for(var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++){\n                        var options = allOptions_1[_i];\n                        if (options.didParseCell) result.didParseCell.push(options.didParseCell);\n                        if (options.willDrawCell) result.willDrawCell.push(options.willDrawCell);\n                        if (options.didDrawCell) result.didDrawCell.push(options.didDrawCell);\n                        if (options.willDrawPage) result.willDrawPage.push(options.willDrawPage);\n                        if (options.didDrawPage) result.didDrawPage.push(options.didDrawPage);\n                    }\n                    return result;\n                }\n                function parseSettings(doc, options) {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n                    var margin = (0, common_1.parseSpacing)(options.margin, 40 / doc.scaleFactor());\n                    var startY = (_a = getStartY(doc, options.startY)) !== null && _a !== void 0 ? _a : margin.top;\n                    var showFoot;\n                    if (options.showFoot === true) {\n                        showFoot = \"everyPage\";\n                    } else if (options.showFoot === false) {\n                        showFoot = \"never\";\n                    } else {\n                        showFoot = (_b = options.showFoot) !== null && _b !== void 0 ? _b : \"everyPage\";\n                    }\n                    var showHead;\n                    if (options.showHead === true) {\n                        showHead = \"everyPage\";\n                    } else if (options.showHead === false) {\n                        showHead = \"never\";\n                    } else {\n                        showHead = (_c = options.showHead) !== null && _c !== void 0 ? _c : \"everyPage\";\n                    }\n                    var useCss = (_d = options.useCss) !== null && _d !== void 0 ? _d : false;\n                    var theme = options.theme || (useCss ? \"plain\" : \"striped\");\n                    var horizontalPageBreak = !!options.horizontalPageBreak;\n                    var horizontalPageBreakRepeat = (_e = options.horizontalPageBreakRepeat) !== null && _e !== void 0 ? _e : null;\n                    return {\n                        includeHiddenHtml: (_f = options.includeHiddenHtml) !== null && _f !== void 0 ? _f : false,\n                        useCss: useCss,\n                        theme: theme,\n                        startY: startY,\n                        margin: margin,\n                        pageBreak: (_g = options.pageBreak) !== null && _g !== void 0 ? _g : \"auto\",\n                        rowPageBreak: (_h = options.rowPageBreak) !== null && _h !== void 0 ? _h : \"auto\",\n                        tableWidth: (_j = options.tableWidth) !== null && _j !== void 0 ? _j : \"auto\",\n                        showHead: showHead,\n                        showFoot: showFoot,\n                        tableLineWidth: (_k = options.tableLineWidth) !== null && _k !== void 0 ? _k : 0,\n                        tableLineColor: (_l = options.tableLineColor) !== null && _l !== void 0 ? _l : 200,\n                        horizontalPageBreak: horizontalPageBreak,\n                        horizontalPageBreakRepeat: horizontalPageBreakRepeat,\n                        horizontalPageBreakBehaviour: (_m = options.horizontalPageBreakBehaviour) !== null && _m !== void 0 ? _m : \"afterAllRows\"\n                    };\n                }\n                function getStartY(doc, userStartY) {\n                    var previous = doc.getLastAutoTable();\n                    var sf = doc.scaleFactor();\n                    var currentPage = doc.pageNumber();\n                    var isSamePageAsPreviousTable = false;\n                    if (previous && previous.startPageNumber) {\n                        var endingPage = previous.startPageNumber + previous.pageNumber - 1;\n                        isSamePageAsPreviousTable = endingPage === currentPage;\n                    }\n                    if (typeof userStartY === \"number\") {\n                        return userStartY;\n                    } else if (userStartY == null || userStartY === false) {\n                        if (isSamePageAsPreviousTable && (previous === null || previous === void 0 ? void 0 : previous.finalY) != null) {\n                            // Some users had issues with overlapping tables when they used multiple\n                            // tables without setting startY so setting it here to a sensible default.\n                            return previous.finalY + 20 / sf;\n                        }\n                    }\n                    return null;\n                }\n                function parseContent(doc, options, window1) {\n                    var head = options.head || [];\n                    var body = options.body || [];\n                    var foot = options.foot || [];\n                    if (options.html) {\n                        var hidden = options.includeHiddenHtml;\n                        if (window1) {\n                            var htmlContent = (0, htmlParser_1.parseHtml)(doc, options.html, window1, hidden, options.useCss) || {};\n                            head = htmlContent.head || head;\n                            body = htmlContent.body || head;\n                            foot = htmlContent.foot || head;\n                        } else {\n                            console.error(\"Cannot parse html in non browser environment\");\n                        }\n                    }\n                    var columns = options.columns || parseColumns(head, body, foot);\n                    return {\n                        columns: columns,\n                        head: head,\n                        body: body,\n                        foot: foot\n                    };\n                }\n                function parseColumns(head, body, foot) {\n                    var firstRow = head[0] || body[0] || foot[0] || [];\n                    var result = [];\n                    Object.keys(firstRow).filter(function(key) {\n                        return key !== \"_element\";\n                    }).forEach(function(key) {\n                        var colSpan = 1;\n                        var input;\n                        if (Array.isArray(firstRow)) {\n                            input = firstRow[parseInt(key)];\n                        } else {\n                            input = firstRow[key];\n                        }\n                        if (typeof input === \"object\" && !Array.isArray(input)) {\n                            colSpan = (input === null || input === void 0 ? void 0 : input.colSpan) || 1;\n                        }\n                        for(var i = 0; i < colSpan; i++){\n                            var id = void 0;\n                            if (Array.isArray(firstRow)) {\n                                id = result.length;\n                            } else {\n                                id = key + (i > 0 ? \"_\".concat(i) : \"\");\n                            }\n                            var rowResult = {\n                                dataKey: id\n                            };\n                            result.push(rowResult);\n                        }\n                    });\n                    return result;\n                }\n            /***/ },\n            /***/ 792: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                function default_1(doc, global1, document, current) {\n                    var _loop_1 = function(options) {\n                        if (options && typeof options !== \"object\") {\n                            console.error(\"The options parameter should be of type object, is: \" + typeof options);\n                        }\n                        if (typeof options.extendWidth !== \"undefined\") {\n                            options.tableWidth = options.extendWidth ? \"auto\" : \"wrap\";\n                            console.error(\"Use of deprecated option: extendWidth, use tableWidth instead.\");\n                        }\n                        if (typeof options.margins !== \"undefined\") {\n                            if (typeof options.margin === \"undefined\") options.margin = options.margins;\n                            console.error(\"Use of deprecated option: margins, use margin instead.\");\n                        }\n                        if (options.startY && typeof options.startY !== \"number\") {\n                            console.error(\"Invalid value for startY option\", options.startY);\n                            delete options.startY;\n                        }\n                        if (!options.didDrawPage && (options.afterPageContent || options.beforePageContent || options.afterPageAdd)) {\n                            console.error(\"The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead\");\n                            options.didDrawPage = function(data) {\n                                doc.applyStyles(doc.userStyles);\n                                if (options.beforePageContent) options.beforePageContent(data);\n                                doc.applyStyles(doc.userStyles);\n                                if (options.afterPageContent) options.afterPageContent(data);\n                                doc.applyStyles(doc.userStyles);\n                                if (options.afterPageAdd && data.pageNumber > 1) {\n                                    ;\n                                    data.afterPageAdd(data);\n                                }\n                                doc.applyStyles(doc.userStyles);\n                            };\n                        }\n                        ;\n                        [\n                            \"createdHeaderCell\",\n                            \"drawHeaderRow\",\n                            \"drawRow\",\n                            \"drawHeaderCell\"\n                        ].forEach(function(name) {\n                            if (options[name]) {\n                                console.error('The \"'.concat(name, '\" hook has changed in version 3.0, check the changelog for how to migrate.'));\n                            }\n                        });\n                        [\n                            [\n                                \"showFoot\",\n                                \"showFooter\"\n                            ],\n                            [\n                                \"showHead\",\n                                \"showHeader\"\n                            ],\n                            [\n                                \"didDrawPage\",\n                                \"addPageContent\"\n                            ],\n                            [\n                                \"didParseCell\",\n                                \"createdCell\"\n                            ],\n                            [\n                                \"headStyles\",\n                                \"headerStyles\"\n                            ]\n                        ].forEach(function(_a) {\n                            var current = _a[0], deprecated = _a[1];\n                            if (options[deprecated]) {\n                                console.error(\"Use of deprecated option \".concat(deprecated, \". Use \").concat(current, \" instead\"));\n                                options[current] = options[deprecated];\n                            }\n                        });\n                        [\n                            [\n                                \"padding\",\n                                \"cellPadding\"\n                            ],\n                            [\n                                \"lineHeight\",\n                                \"rowHeight\"\n                            ],\n                            \"fontSize\",\n                            \"overflow\"\n                        ].forEach(function(o) {\n                            var deprecatedOption = typeof o === \"string\" ? o : o[0];\n                            var style = typeof o === \"string\" ? o : o[1];\n                            if (typeof options[deprecatedOption] !== \"undefined\") {\n                                if (typeof options.styles[style] === \"undefined\") {\n                                    options.styles[style] = options[deprecatedOption];\n                                }\n                                console.error(\"Use of deprecated option: \" + deprecatedOption + \", use the style \" + style + \" instead.\");\n                            }\n                        });\n                        for(var _b = 0, _c = [\n                            \"styles\",\n                            \"bodyStyles\",\n                            \"headStyles\",\n                            \"footStyles\"\n                        ]; _b < _c.length; _b++){\n                            var styleProp = _c[_b];\n                            checkStyles(options[styleProp] || {});\n                        }\n                        var columnStyles = options[\"columnStyles\"] || {};\n                        for(var _d = 0, _e = Object.keys(columnStyles); _d < _e.length; _d++){\n                            var key = _e[_d];\n                            checkStyles(columnStyles[key] || {});\n                        }\n                    };\n                    for(var _i = 0, _a = [\n                        global1,\n                        document,\n                        current\n                    ]; _i < _a.length; _i++){\n                        var options = _a[_i];\n                        _loop_1(options);\n                    }\n                }\n                exports1[\"default\"] = default_1;\n                function checkStyles(styles) {\n                    if (styles.rowHeight) {\n                        console.error(\"Use of deprecated style rowHeight. It is renamed to minCellHeight.\");\n                        if (!styles.minCellHeight) {\n                            styles.minCellHeight = styles.rowHeight;\n                        }\n                    } else if (styles.columnWidth) {\n                        console.error(\"Use of deprecated style columnWidth. It is renamed to cellWidth.\");\n                        if (!styles.cellWidth) {\n                            styles.cellWidth = styles.columnWidth;\n                        }\n                    }\n                }\n            /***/ },\n            /***/ 260: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_62389__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Column = exports1.Cell = exports1.Row = exports1.Table = void 0;\n                var config_1 = __nested_webpack_require_62389__(796);\n                var HookData_1 = __nested_webpack_require_62389__(172);\n                var common_1 = __nested_webpack_require_62389__(420);\n                var Table = /** @class */ function() {\n                    function Table(input, content) {\n                        this.pageNumber = 1;\n                        // Deprecated, use pageNumber instead\n                        // Not using getter since:\n                        // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/596\n                        this.pageCount = 1;\n                        this.id = input.id;\n                        this.settings = input.settings;\n                        this.styles = input.styles;\n                        this.hooks = input.hooks;\n                        this.columns = content.columns;\n                        this.head = content.head;\n                        this.body = content.body;\n                        this.foot = content.foot;\n                    }\n                    Table.prototype.getHeadHeight = function(columns) {\n                        return this.head.reduce(function(acc, row) {\n                            return acc + row.getMaxCellHeight(columns);\n                        }, 0);\n                    };\n                    Table.prototype.getFootHeight = function(columns) {\n                        return this.foot.reduce(function(acc, row) {\n                            return acc + row.getMaxCellHeight(columns);\n                        }, 0);\n                    };\n                    Table.prototype.allRows = function() {\n                        return this.head.concat(this.body).concat(this.foot);\n                    };\n                    Table.prototype.callCellHooks = function(doc, handlers, cell, row, column, cursor) {\n                        for(var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++){\n                            var handler = handlers_1[_i];\n                            var data = new HookData_1.CellHookData(doc, this, cell, row, column, cursor);\n                            var result = handler(data) === false;\n                            // Make sure text is always string[] since user can assign string\n                            cell.text = Array.isArray(cell.text) ? cell.text : [\n                                cell.text\n                            ];\n                            if (result) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    };\n                    Table.prototype.callEndPageHooks = function(doc, cursor) {\n                        doc.applyStyles(doc.userStyles);\n                        for(var _i = 0, _a = this.hooks.didDrawPage; _i < _a.length; _i++){\n                            var handler = _a[_i];\n                            handler(new HookData_1.HookData(doc, this, cursor));\n                        }\n                    };\n                    Table.prototype.callWillDrawPageHooks = function(doc, cursor) {\n                        for(var _i = 0, _a = this.hooks.willDrawPage; _i < _a.length; _i++){\n                            var handler = _a[_i];\n                            handler(new HookData_1.HookData(doc, this, cursor));\n                        }\n                    };\n                    Table.prototype.getWidth = function(pageWidth) {\n                        if (typeof this.settings.tableWidth === \"number\") {\n                            return this.settings.tableWidth;\n                        } else if (this.settings.tableWidth === \"wrap\") {\n                            var wrappedWidth = this.columns.reduce(function(total, col) {\n                                return total + col.wrappedWidth;\n                            }, 0);\n                            return wrappedWidth;\n                        } else {\n                            var margin = this.settings.margin;\n                            return pageWidth - margin.left - margin.right;\n                        }\n                    };\n                    return Table;\n                }();\n                exports1.Table = Table;\n                var Row = /** @class */ function() {\n                    function Row(raw, index, section, cells, spansMultiplePages) {\n                        if (spansMultiplePages === void 0) {\n                            spansMultiplePages = false;\n                        }\n                        this.height = 0;\n                        this.raw = raw;\n                        if (raw instanceof config_1.HtmlRowInput) {\n                            this.raw = raw._element;\n                            this.element = raw._element;\n                        }\n                        this.index = index;\n                        this.section = section;\n                        this.cells = cells;\n                        this.spansMultiplePages = spansMultiplePages;\n                    }\n                    Row.prototype.getMaxCellHeight = function(columns) {\n                        var _this = this;\n                        return columns.reduce(function(acc, column) {\n                            var _a;\n                            return Math.max(acc, ((_a = _this.cells[column.index]) === null || _a === void 0 ? void 0 : _a.height) || 0);\n                        }, 0);\n                    };\n                    Row.prototype.hasRowSpan = function(columns) {\n                        var _this = this;\n                        return columns.filter(function(column) {\n                            var cell = _this.cells[column.index];\n                            if (!cell) return false;\n                            return cell.rowSpan > 1;\n                        }).length > 0;\n                    };\n                    Row.prototype.canEntireRowFit = function(height, columns) {\n                        return this.getMaxCellHeight(columns) <= height;\n                    };\n                    Row.prototype.getMinimumRowHeight = function(columns, doc) {\n                        var _this = this;\n                        return columns.reduce(function(acc, column) {\n                            var cell = _this.cells[column.index];\n                            if (!cell) return 0;\n                            var lineHeight = doc.getLineHeight(cell.styles.fontSize);\n                            var vPadding = cell.padding(\"vertical\");\n                            var oneRowHeight = vPadding + lineHeight;\n                            return oneRowHeight > acc ? oneRowHeight : acc;\n                        }, 0);\n                    };\n                    return Row;\n                }();\n                exports1.Row = Row;\n                var Cell = /** @class */ function() {\n                    function Cell(raw, styles, section) {\n                        var _a, _b;\n                        this.contentHeight = 0;\n                        this.contentWidth = 0;\n                        this.wrappedWidth = 0;\n                        this.minReadableWidth = 0;\n                        this.minWidth = 0;\n                        this.width = 0;\n                        this.height = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this.styles = styles;\n                        this.section = section;\n                        this.raw = raw;\n                        var content = raw;\n                        if (raw != null && typeof raw === \"object\" && !Array.isArray(raw)) {\n                            this.rowSpan = raw.rowSpan || 1;\n                            this.colSpan = raw.colSpan || 1;\n                            content = (_b = (_a = raw.content) !== null && _a !== void 0 ? _a : raw.title) !== null && _b !== void 0 ? _b : raw;\n                            if (raw._element) {\n                                this.raw = raw._element;\n                            }\n                        } else {\n                            this.rowSpan = 1;\n                            this.colSpan = 1;\n                        }\n                        // Stringify 0 and false, but not undefined or null\n                        var text = content != null ? \"\" + content : \"\";\n                        var splitRegex = /\\r\\n|\\r|\\n/g;\n                        this.text = text.split(splitRegex);\n                    }\n                    Cell.prototype.getTextPos = function() {\n                        var y;\n                        if (this.styles.valign === \"top\") {\n                            y = this.y + this.padding(\"top\");\n                        } else if (this.styles.valign === \"bottom\") {\n                            y = this.y + this.height - this.padding(\"bottom\");\n                        } else {\n                            var netHeight = this.height - this.padding(\"vertical\");\n                            y = this.y + netHeight / 2 + this.padding(\"top\");\n                        }\n                        var x;\n                        if (this.styles.halign === \"right\") {\n                            x = this.x + this.width - this.padding(\"right\");\n                        } else if (this.styles.halign === \"center\") {\n                            var netWidth = this.width - this.padding(\"horizontal\");\n                            x = this.x + netWidth / 2 + this.padding(\"left\");\n                        } else {\n                            x = this.x + this.padding(\"left\");\n                        }\n                        return {\n                            x: x,\n                            y: y\n                        };\n                    };\n                    // TODO (v4): replace parameters with only (lineHeight)\n                    Cell.prototype.getContentHeight = function(scaleFactor, lineHeightFactor) {\n                        if (lineHeightFactor === void 0) {\n                            lineHeightFactor = 1.15;\n                        }\n                        var lineCount = Array.isArray(this.text) ? this.text.length : 1;\n                        var lineHeight = this.styles.fontSize / scaleFactor * lineHeightFactor;\n                        var height = lineCount * lineHeight + this.padding(\"vertical\");\n                        return Math.max(height, this.styles.minCellHeight);\n                    };\n                    Cell.prototype.padding = function(name) {\n                        var padding = (0, common_1.parseSpacing)(this.styles.cellPadding, 0);\n                        if (name === \"vertical\") {\n                            return padding.top + padding.bottom;\n                        } else if (name === \"horizontal\") {\n                            return padding.left + padding.right;\n                        } else {\n                            return padding[name];\n                        }\n                    };\n                    return Cell;\n                }();\n                exports1.Cell = Cell;\n                var Column = /** @class */ function() {\n                    function Column(dataKey, raw, index) {\n                        this.wrappedWidth = 0;\n                        this.minReadableWidth = 0;\n                        this.minWidth = 0;\n                        this.width = 0;\n                        this.dataKey = dataKey;\n                        this.raw = raw;\n                        this.index = index;\n                    }\n                    Column.prototype.getMaxCustomCellWidth = function(table) {\n                        var max = 0;\n                        for(var _i = 0, _a = table.allRows(); _i < _a.length; _i++){\n                            var row = _a[_i];\n                            var cell = row.cells[this.index];\n                            if (cell && typeof cell.styles.cellWidth === \"number\") {\n                                max = Math.max(max, cell.styles.cellWidth);\n                            }\n                        }\n                        return max;\n                    };\n                    return Column;\n                }();\n                exports1.Column = Column;\n            /***/ },\n            /***/ 356: /***/ function(__unused_webpack_module, exports1) {\n                /* eslint-disable @typescript-eslint/no-unused-vars */ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.assign = void 0;\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n                function assign(target, s, s1, s2, s3) {\n                    if (target == null) {\n                        throw new TypeError(\"Cannot convert undefined or null to object\");\n                    }\n                    var to = Object(target);\n                    for(var index = 1; index < arguments.length; index++){\n                        // eslint-disable-next-line prefer-rest-params\n                        var nextSource = arguments[index];\n                        if (nextSource != null) {\n                            // Skip over if undefined or null\n                            for(var nextKey in nextSource){\n                                // Avoid bugs when hasOwnProperty is shadowed\n                                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                    to[nextKey] = nextSource[nextKey];\n                                }\n                            }\n                        }\n                    }\n                    return to;\n                }\n                exports1.assign = assign;\n            /***/ },\n            /***/ 972: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_76274__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.createTable = void 0;\n                var documentHandler_1 = __nested_webpack_require_76274__(744);\n                var models_1 = __nested_webpack_require_76274__(260);\n                var widthCalculator_1 = __nested_webpack_require_76274__(324);\n                var config_1 = __nested_webpack_require_76274__(796);\n                var polyfills_1 = __nested_webpack_require_76274__(356);\n                function createTable(jsPDFDoc, input) {\n                    var doc = new documentHandler_1.DocHandler(jsPDFDoc);\n                    var content = parseContent(input, doc.scaleFactor());\n                    var table = new models_1.Table(input, content);\n                    (0, widthCalculator_1.calculateWidths)(doc, table);\n                    doc.applyStyles(doc.userStyles);\n                    return table;\n                }\n                exports1.createTable = createTable;\n                function parseContent(input, sf) {\n                    var content = input.content;\n                    var columns = createColumns(content.columns);\n                    // If no head or foot is set, try generating it with content from columns\n                    if (content.head.length === 0) {\n                        var sectionRow = generateSectionRow(columns, \"head\");\n                        if (sectionRow) content.head.push(sectionRow);\n                    }\n                    if (content.foot.length === 0) {\n                        var sectionRow = generateSectionRow(columns, \"foot\");\n                        if (sectionRow) content.foot.push(sectionRow);\n                    }\n                    var theme = input.settings.theme;\n                    var styles = input.styles;\n                    return {\n                        columns: columns,\n                        head: parseSection(\"head\", content.head, columns, styles, theme, sf),\n                        body: parseSection(\"body\", content.body, columns, styles, theme, sf),\n                        foot: parseSection(\"foot\", content.foot, columns, styles, theme, sf)\n                    };\n                }\n                function parseSection(sectionName, sectionRows, columns, styleProps, theme, scaleFactor) {\n                    var rowSpansLeftForColumn = {};\n                    var result = sectionRows.map(function(rawRow, rowIndex) {\n                        var skippedRowForRowSpans = 0;\n                        var cells = {};\n                        var colSpansAdded = 0;\n                        var columnSpansLeft = 0;\n                        for(var _i = 0, columns_1 = columns; _i < columns_1.length; _i++){\n                            var column = columns_1[_i];\n                            if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {\n                                if (columnSpansLeft === 0) {\n                                    var rawCell = void 0;\n                                    if (Array.isArray(rawRow)) {\n                                        rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];\n                                    } else {\n                                        rawCell = rawRow[column.dataKey];\n                                    }\n                                    var cellInputStyles = {};\n                                    if (typeof rawCell === \"object\" && !Array.isArray(rawCell)) {\n                                        cellInputStyles = (rawCell === null || rawCell === void 0 ? void 0 : rawCell.styles) || {};\n                                    }\n                                    var styles = cellStyles(sectionName, column, rowIndex, theme, styleProps, scaleFactor, cellInputStyles);\n                                    var cell = new models_1.Cell(rawCell, styles, sectionName);\n                                    // dataKey is not used internally no more but keep for\n                                    // backwards compat in hooks\n                                    cells[column.dataKey] = cell;\n                                    cells[column.index] = cell;\n                                    columnSpansLeft = cell.colSpan - 1;\n                                    rowSpansLeftForColumn[column.index] = {\n                                        left: cell.rowSpan - 1,\n                                        times: columnSpansLeft\n                                    };\n                                } else {\n                                    columnSpansLeft--;\n                                    colSpansAdded++;\n                                }\n                            } else {\n                                rowSpansLeftForColumn[column.index].left--;\n                                columnSpansLeft = rowSpansLeftForColumn[column.index].times;\n                                skippedRowForRowSpans++;\n                            }\n                        }\n                        return new models_1.Row(rawRow, rowIndex, sectionName, cells);\n                    });\n                    return result;\n                }\n                function generateSectionRow(columns, section) {\n                    var sectionRow = {};\n                    columns.forEach(function(col) {\n                        if (col.raw != null) {\n                            var title = getSectionTitle(section, col.raw);\n                            if (title != null) sectionRow[col.dataKey] = title;\n                        }\n                    });\n                    return Object.keys(sectionRow).length > 0 ? sectionRow : null;\n                }\n                function getSectionTitle(section, column) {\n                    if (section === \"head\") {\n                        if (typeof column === \"object\") {\n                            return column.header || column.title || null;\n                        } else if (typeof column === \"string\" || typeof column === \"number\") {\n                            return column;\n                        }\n                    } else if (section === \"foot\" && typeof column === \"object\") {\n                        return column.footer;\n                    }\n                    return null;\n                }\n                function createColumns(columns) {\n                    return columns.map(function(input, index) {\n                        var _a, _b;\n                        var key;\n                        if (typeof input === \"object\") {\n                            key = (_b = (_a = input.dataKey) !== null && _a !== void 0 ? _a : input.key) !== null && _b !== void 0 ? _b : index;\n                        } else {\n                            key = index;\n                        }\n                        return new models_1.Column(key, input, index);\n                    });\n                }\n                function cellStyles(sectionName, column, rowIndex, themeName, styles, scaleFactor, cellInputStyles) {\n                    var theme = (0, config_1.getTheme)(themeName);\n                    var sectionStyles;\n                    if (sectionName === \"head\") {\n                        sectionStyles = styles.headStyles;\n                    } else if (sectionName === \"body\") {\n                        sectionStyles = styles.bodyStyles;\n                    } else if (sectionName === \"foot\") {\n                        sectionStyles = styles.footStyles;\n                    }\n                    var otherStyles = (0, polyfills_1.assign)({}, theme.table, theme[sectionName], styles.styles, sectionStyles);\n                    var columnStyles = styles.columnStyles[column.dataKey] || styles.columnStyles[column.index] || {};\n                    var colStyles = sectionName === \"body\" ? columnStyles : {};\n                    var rowStyles = sectionName === \"body\" && rowIndex % 2 === 0 ? (0, polyfills_1.assign)({}, theme.alternateRow, styles.alternateRowStyles) : {};\n                    var defaultStyle = (0, config_1.defaultStyles)(scaleFactor);\n                    var themeStyles = (0, polyfills_1.assign)({}, defaultStyle, otherStyles, rowStyles, colStyles);\n                    return (0, polyfills_1.assign)(themeStyles, cellInputStyles);\n                }\n            /***/ },\n            /***/ 664: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_84642__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.addPage = exports1.drawTable = void 0;\n                var common_1 = __nested_webpack_require_84642__(420);\n                var models_1 = __nested_webpack_require_84642__(260);\n                var documentHandler_1 = __nested_webpack_require_84642__(744);\n                var polyfills_1 = __nested_webpack_require_84642__(356);\n                var autoTableText_1 = __nested_webpack_require_84642__(136);\n                var tablePrinter_1 = __nested_webpack_require_84642__(224);\n                function drawTable(jsPDFDoc, table) {\n                    var settings = table.settings;\n                    var startY = settings.startY;\n                    var margin = settings.margin;\n                    var cursor = {\n                        x: margin.left,\n                        y: startY\n                    };\n                    var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);\n                    var minTableBottomPos = startY + margin.bottom + sectionsHeight;\n                    if (settings.pageBreak === \"avoid\") {\n                        var rows = table.body;\n                        var tableHeight = rows.reduce(function(acc, row) {\n                            return acc + row.height;\n                        }, 0);\n                        minTableBottomPos += tableHeight;\n                    }\n                    var doc = new documentHandler_1.DocHandler(jsPDFDoc);\n                    if (settings.pageBreak === \"always\" || settings.startY != null && minTableBottomPos > doc.pageSize().height) {\n                        nextPage(doc);\n                        cursor.y = margin.top;\n                    }\n                    table.callWillDrawPageHooks(doc, cursor);\n                    var startPos = (0, polyfills_1.assign)({}, cursor);\n                    table.startPageNumber = doc.pageNumber();\n                    if (settings.horizontalPageBreak) {\n                        // managed flow for split columns\n                        printTableWithHorizontalPageBreak(doc, table, startPos, cursor);\n                    } else {\n                        // normal flow\n                        doc.applyStyles(doc.userStyles);\n                        if (settings.showHead === \"firstPage\" || settings.showHead === \"everyPage\") {\n                            table.head.forEach(function(row) {\n                                return printRow(doc, table, row, cursor, table.columns);\n                            });\n                        }\n                        doc.applyStyles(doc.userStyles);\n                        table.body.forEach(function(row, index) {\n                            var isLastRow = index === table.body.length - 1;\n                            printFullRow(doc, table, row, isLastRow, startPos, cursor, table.columns);\n                        });\n                        doc.applyStyles(doc.userStyles);\n                        if (settings.showFoot === \"lastPage\" || settings.showFoot === \"everyPage\") {\n                            table.foot.forEach(function(row) {\n                                return printRow(doc, table, row, cursor, table.columns);\n                            });\n                        }\n                    }\n                    (0, common_1.addTableBorder)(doc, table, startPos, cursor);\n                    table.callEndPageHooks(doc, cursor);\n                    table.finalY = cursor.y;\n                    jsPDFDoc.lastAutoTable = table;\n                    jsPDFDoc.previousAutoTable = table; // Deprecated\n                    if (jsPDFDoc.autoTable) jsPDFDoc.autoTable.previous = table; // Deprecated\n                    doc.applyStyles(doc.userStyles);\n                }\n                exports1.drawTable = drawTable;\n                function printTableWithHorizontalPageBreak(doc, table, startPos, cursor) {\n                    // calculate width of columns and render only those which can fit into page\n                    var allColumnsCanFitResult = (0, tablePrinter_1.calculateAllColumnsCanFitInPage)(doc, table);\n                    var settings = table.settings;\n                    if (settings.horizontalPageBreakBehaviour === \"afterAllRows\") {\n                        allColumnsCanFitResult.forEach(function(colsAndIndexes, index) {\n                            doc.applyStyles(doc.userStyles);\n                            // add page to print next columns in new page\n                            if (index > 0) {\n                                // When adding a page here, make sure not to print the footers\n                                // because they were already printed before on this same loop\n                                addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);\n                            } else {\n                                // print head for selected columns\n                                printHead(doc, table, cursor, colsAndIndexes.columns);\n                            }\n                            // print body & footer for selected columns\n                            printBody(doc, table, startPos, cursor, colsAndIndexes.columns);\n                            printFoot(doc, table, cursor, colsAndIndexes.columns);\n                        });\n                    } else {\n                        var lastRowIndexOfLastPage_1 = -1;\n                        var firstColumnsToFitResult = allColumnsCanFitResult[0];\n                        var _loop_1 = function() {\n                            // Print the first columns, taking note of the last row printed\n                            var lastPrintedRowIndex = lastRowIndexOfLastPage_1;\n                            if (firstColumnsToFitResult) {\n                                doc.applyStyles(doc.userStyles);\n                                var firstColumnsToFit = firstColumnsToFitResult.columns;\n                                if (lastRowIndexOfLastPage_1 >= 0) {\n                                    // When adding a page here, make sure not to print the footers\n                                    // because they were already printed before on this same loop\n                                    addPage(doc, table, startPos, cursor, firstColumnsToFit, true);\n                                } else {\n                                    printHead(doc, table, cursor, firstColumnsToFit);\n                                }\n                                lastPrintedRowIndex = printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, firstColumnsToFit);\n                                printFoot(doc, table, cursor, firstColumnsToFit);\n                            }\n                            // Check how many rows were printed, so that the next columns would not print more rows than that\n                            var maxNumberOfRows = lastPrintedRowIndex - lastRowIndexOfLastPage_1;\n                            // Print the next columns, never exceding maxNumberOfRows\n                            allColumnsCanFitResult.slice(1).forEach(function(colsAndIndexes) {\n                                doc.applyStyles(doc.userStyles);\n                                // When adding a page here, make sure not to print the footers\n                                // because they were already printed before on this same loop\n                                addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);\n                                printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, colsAndIndexes.columns, maxNumberOfRows);\n                                printFoot(doc, table, cursor, colsAndIndexes.columns);\n                            });\n                            lastRowIndexOfLastPage_1 = lastPrintedRowIndex;\n                        };\n                        while(lastRowIndexOfLastPage_1 < table.body.length - 1){\n                            _loop_1();\n                        }\n                    }\n                }\n                function printHead(doc, table, cursor, columns) {\n                    var settings = table.settings;\n                    doc.applyStyles(doc.userStyles);\n                    if (settings.showHead === \"firstPage\" || settings.showHead === \"everyPage\") {\n                        table.head.forEach(function(row) {\n                            return printRow(doc, table, row, cursor, columns);\n                        });\n                    }\n                }\n                function printBody(doc, table, startPos, cursor, columns) {\n                    doc.applyStyles(doc.userStyles);\n                    table.body.forEach(function(row, index) {\n                        var isLastRow = index === table.body.length - 1;\n                        printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);\n                    });\n                }\n                function printBodyWithoutPageBreaks(doc, table, startRowIndex, cursor, columns, maxNumberOfRows) {\n                    doc.applyStyles(doc.userStyles);\n                    maxNumberOfRows = maxNumberOfRows !== null && maxNumberOfRows !== void 0 ? maxNumberOfRows : table.body.length;\n                    var endRowIndex = Math.min(startRowIndex + maxNumberOfRows, table.body.length);\n                    var lastPrintedRowIndex = -1;\n                    table.body.slice(startRowIndex, endRowIndex).forEach(function(row, index) {\n                        var isLastRow = startRowIndex + index === table.body.length - 1;\n                        var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);\n                        if (row.canEntireRowFit(remainingSpace, columns)) {\n                            printRow(doc, table, row, cursor, columns);\n                            lastPrintedRowIndex = startRowIndex + index;\n                        }\n                    });\n                    return lastPrintedRowIndex;\n                }\n                function printFoot(doc, table, cursor, columns) {\n                    var settings = table.settings;\n                    doc.applyStyles(doc.userStyles);\n                    if (settings.showFoot === \"lastPage\" || settings.showFoot === \"everyPage\") {\n                        table.foot.forEach(function(row) {\n                            return printRow(doc, table, row, cursor, columns);\n                        });\n                    }\n                }\n                function getRemainingLineCount(cell, remainingPageSpace, doc) {\n                    var lineHeight = doc.getLineHeight(cell.styles.fontSize);\n                    var vPadding = cell.padding(\"vertical\");\n                    var remainingLines = Math.floor((remainingPageSpace - vPadding) / lineHeight);\n                    return Math.max(0, remainingLines);\n                }\n                function modifyRowToFit(row, remainingPageSpace, table, doc) {\n                    var cells = {};\n                    row.spansMultiplePages = true;\n                    row.height = 0;\n                    var rowHeight = 0;\n                    for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n                        var column = _a[_i];\n                        var cell = row.cells[column.index];\n                        if (!cell) continue;\n                        if (!Array.isArray(cell.text)) {\n                            cell.text = [\n                                cell.text\n                            ];\n                        }\n                        var remainderCell = new models_1.Cell(cell.raw, cell.styles, cell.section);\n                        remainderCell = (0, polyfills_1.assign)(remainderCell, cell);\n                        remainderCell.text = [];\n                        var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace, doc);\n                        if (cell.text.length > remainingLineCount) {\n                            remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);\n                        }\n                        var scaleFactor = doc.scaleFactor();\n                        var lineHeightFactor = doc.getLineHeightFactor();\n                        cell.contentHeight = cell.getContentHeight(scaleFactor, lineHeightFactor);\n                        if (cell.contentHeight >= remainingPageSpace) {\n                            cell.contentHeight = remainingPageSpace;\n                            remainderCell.styles.minCellHeight -= remainingPageSpace;\n                        }\n                        if (cell.contentHeight > row.height) {\n                            row.height = cell.contentHeight;\n                        }\n                        remainderCell.contentHeight = remainderCell.getContentHeight(scaleFactor, lineHeightFactor);\n                        if (remainderCell.contentHeight > rowHeight) {\n                            rowHeight = remainderCell.contentHeight;\n                        }\n                        cells[column.index] = remainderCell;\n                    }\n                    var remainderRow = new models_1.Row(row.raw, -1, row.section, cells, true);\n                    remainderRow.height = rowHeight;\n                    for(var _b = 0, _c = table.columns; _b < _c.length; _b++){\n                        var column = _c[_b];\n                        var remainderCell = remainderRow.cells[column.index];\n                        if (remainderCell) {\n                            remainderCell.height = remainderRow.height;\n                        }\n                        var cell = row.cells[column.index];\n                        if (cell) {\n                            cell.height = row.height;\n                        }\n                    }\n                    return remainderRow;\n                }\n                function shouldPrintOnCurrentPage(doc, row, remainingPageSpace, table) {\n                    var pageHeight = doc.pageSize().height;\n                    var margin = table.settings.margin;\n                    var marginHeight = margin.top + margin.bottom;\n                    var maxRowHeight = pageHeight - marginHeight;\n                    if (row.section === \"body\") {\n                        // Should also take into account that head and foot is not\n                        // on every page with some settings\n                        maxRowHeight -= table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);\n                    }\n                    var minRowHeight = row.getMinimumRowHeight(table.columns, doc);\n                    var minRowFits = minRowHeight < remainingPageSpace;\n                    if (minRowHeight > maxRowHeight) {\n                        console.error(\"Will not be able to print row \".concat(row.index, \" correctly since it's minimum height is larger than page height\"));\n                        return true;\n                    }\n                    if (!minRowFits) {\n                        return false;\n                    }\n                    var rowHasRowSpanCell = row.hasRowSpan(table.columns);\n                    var rowHigherThanPage = row.getMaxCellHeight(table.columns) > maxRowHeight;\n                    if (rowHigherThanPage) {\n                        if (rowHasRowSpanCell) {\n                            console.error(\"The content of row \".concat(row.index, \" will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.\"));\n                        }\n                        return true;\n                    }\n                    if (rowHasRowSpanCell) {\n                        // Currently a new page is required whenever a rowspan row don't fit a page.\n                        return false;\n                    }\n                    if (table.settings.rowPageBreak === \"avoid\") {\n                        return false;\n                    }\n                    // In all other cases print the row on current page\n                    return true;\n                }\n                function printFullRow(doc, table, row, isLastRow, startPos, cursor, columns) {\n                    var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);\n                    if (row.canEntireRowFit(remainingSpace, columns)) {\n                        // The row fits in the current page\n                        printRow(doc, table, row, cursor, columns);\n                    } else if (shouldPrintOnCurrentPage(doc, row, remainingSpace, table)) {\n                        // The row gets split in two here, each piece in one page\n                        var remainderRow = modifyRowToFit(row, remainingSpace, table, doc);\n                        printRow(doc, table, row, cursor, columns);\n                        addPage(doc, table, startPos, cursor, columns);\n                        printFullRow(doc, table, remainderRow, isLastRow, startPos, cursor, columns);\n                    } else {\n                        // The row get printed entirelly on the next page\n                        addPage(doc, table, startPos, cursor, columns);\n                        printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);\n                    }\n                }\n                function printRow(doc, table, row, cursor, columns) {\n                    cursor.x = table.settings.margin.left;\n                    for(var _i = 0, columns_1 = columns; _i < columns_1.length; _i++){\n                        var column = columns_1[_i];\n                        var cell = row.cells[column.index];\n                        if (!cell) {\n                            cursor.x += column.width;\n                            continue;\n                        }\n                        doc.applyStyles(cell.styles);\n                        cell.x = cursor.x;\n                        cell.y = cursor.y;\n                        var result = table.callCellHooks(doc, table.hooks.willDrawCell, cell, row, column, cursor);\n                        if (result === false) {\n                            cursor.x += column.width;\n                            continue;\n                        }\n                        drawCellRect(doc, cell, cursor);\n                        var textPos = cell.getTextPos();\n                        (0, autoTableText_1.default)(cell.text, textPos.x, textPos.y, {\n                            halign: cell.styles.halign,\n                            valign: cell.styles.valign,\n                            maxWidth: Math.ceil(cell.width - cell.padding(\"left\") - cell.padding(\"right\"))\n                        }, doc.getDocument());\n                        table.callCellHooks(doc, table.hooks.didDrawCell, cell, row, column, cursor);\n                        cursor.x += column.width;\n                    }\n                    cursor.y += row.height;\n                }\n                function drawCellRect(doc, cell, cursor) {\n                    var cellStyles = cell.styles;\n                    // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/774\n                    // TODO (v4): better solution?\n                    doc.getDocument().setFillColor(doc.getDocument().getFillColor());\n                    if (typeof cellStyles.lineWidth === \"number\") {\n                        // Draw cell background with normal borders\n                        var fillStyle = (0, common_1.getFillStyle)(cellStyles.lineWidth, cellStyles.fillColor);\n                        if (fillStyle) {\n                            doc.rect(cell.x, cursor.y, cell.width, cell.height, fillStyle);\n                        }\n                    } else if (typeof cellStyles.lineWidth === \"object\") {\n                        // Draw cell background\n                        if (cellStyles.fillColor) {\n                            doc.rect(cell.x, cursor.y, cell.width, cell.height, \"F\");\n                        }\n                        // Draw cell individual borders\n                        drawCellBorders(doc, cell, cursor, cellStyles.lineWidth);\n                    }\n                }\n                /**\n * Draw all specified borders. Borders are centered on cell's edge and lengthened\n * to overlap with neighbours to create sharp corners.\n * @param doc\n * @param cell\n * @param cursor\n * @param fillColor\n * @param lineWidth\n */ function drawCellBorders(doc, cell, cursor, lineWidth) {\n                    var x1, y1, x2, y2;\n                    if (lineWidth.top) {\n                        x1 = cursor.x;\n                        y1 = cursor.y;\n                        x2 = cursor.x + cell.width;\n                        y2 = cursor.y;\n                        if (lineWidth.right) {\n                            x2 += 0.5 * lineWidth.right;\n                        }\n                        if (lineWidth.left) {\n                            x1 -= 0.5 * lineWidth.left;\n                        }\n                        drawLine(lineWidth.top, x1, y1, x2, y2);\n                    }\n                    if (lineWidth.bottom) {\n                        x1 = cursor.x;\n                        y1 = cursor.y + cell.height;\n                        x2 = cursor.x + cell.width;\n                        y2 = cursor.y + cell.height;\n                        if (lineWidth.right) {\n                            x2 += 0.5 * lineWidth.right;\n                        }\n                        if (lineWidth.left) {\n                            x1 -= 0.5 * lineWidth.left;\n                        }\n                        drawLine(lineWidth.bottom, x1, y1, x2, y2);\n                    }\n                    if (lineWidth.left) {\n                        x1 = cursor.x;\n                        y1 = cursor.y;\n                        x2 = cursor.x;\n                        y2 = cursor.y + cell.height;\n                        if (lineWidth.top) {\n                            y1 -= 0.5 * lineWidth.top;\n                        }\n                        if (lineWidth.bottom) {\n                            y2 += 0.5 * lineWidth.bottom;\n                        }\n                        drawLine(lineWidth.left, x1, y1, x2, y2);\n                    }\n                    if (lineWidth.right) {\n                        x1 = cursor.x + cell.width;\n                        y1 = cursor.y;\n                        x2 = cursor.x + cell.width;\n                        y2 = cursor.y + cell.height;\n                        if (lineWidth.top) {\n                            y1 -= 0.5 * lineWidth.top;\n                        }\n                        if (lineWidth.bottom) {\n                            y2 += 0.5 * lineWidth.bottom;\n                        }\n                        drawLine(lineWidth.right, x1, y1, x2, y2);\n                    }\n                    function drawLine(width, x1, y1, x2, y2) {\n                        doc.getDocument().setLineWidth(width);\n                        doc.getDocument().line(x1, y1, x2, y2, \"S\");\n                    }\n                }\n                function getRemainingPageSpace(doc, table, isLastRow, cursor) {\n                    var bottomContentHeight = table.settings.margin.bottom;\n                    var showFoot = table.settings.showFoot;\n                    if (showFoot === \"everyPage\" || showFoot === \"lastPage\" && isLastRow) {\n                        bottomContentHeight += table.getFootHeight(table.columns);\n                    }\n                    return doc.pageSize().height - cursor.y - bottomContentHeight;\n                }\n                function addPage(doc, table, startPos, cursor, columns, suppressFooter) {\n                    if (columns === void 0) {\n                        columns = [];\n                    }\n                    if (suppressFooter === void 0) {\n                        suppressFooter = false;\n                    }\n                    doc.applyStyles(doc.userStyles);\n                    if (table.settings.showFoot === \"everyPage\" && !suppressFooter) {\n                        table.foot.forEach(function(row) {\n                            return printRow(doc, table, row, cursor, columns);\n                        });\n                    }\n                    // Add user content just before adding new page ensure it will\n                    // be drawn above other things on the page\n                    table.callEndPageHooks(doc, cursor);\n                    var margin = table.settings.margin;\n                    (0, common_1.addTableBorder)(doc, table, startPos, cursor);\n                    nextPage(doc);\n                    table.pageNumber++;\n                    table.pageCount++;\n                    cursor.x = margin.left;\n                    cursor.y = margin.top;\n                    startPos.y = margin.top;\n                    // call didAddPage hooks before any content is added to the page\n                    table.callWillDrawPageHooks(doc, cursor);\n                    if (table.settings.showHead === \"everyPage\") {\n                        table.head.forEach(function(row) {\n                            return printRow(doc, table, row, cursor, columns);\n                        });\n                        doc.applyStyles(doc.userStyles);\n                    }\n                }\n                exports1.addPage = addPage;\n                function nextPage(doc) {\n                    var current = doc.pageNumber();\n                    doc.setPage(current + 1);\n                    var newCurrent = doc.pageNumber();\n                    if (newCurrent === current) {\n                        doc.addPage();\n                        return true;\n                    }\n                    return false;\n                }\n            /***/ },\n            /***/ 224: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_110315__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.calculateAllColumnsCanFitInPage = void 0;\n                var common_1 = __nested_webpack_require_110315__(420);\n                // get columns can be fit into page\n                function getColumnsCanFitInPage(doc, table, config) {\n                    var _a;\n                    if (config === void 0) {\n                        config = {};\n                    }\n                    // Get page width\n                    var remainingWidth = (0, common_1.getPageAvailableWidth)(doc, table);\n                    // Get column data key to repeat\n                    var repeatColumnsMap = new Map();\n                    var colIndexes = [];\n                    var columns = [];\n                    var horizontalPageBreakRepeat = [];\n                    table.settings.horizontalPageBreakRepeat;\n                    if (Array.isArray(table.settings.horizontalPageBreakRepeat)) {\n                        horizontalPageBreakRepeat = table.settings.horizontalPageBreakRepeat;\n                    // It can be a single value of type string or number (even number: 0)\n                    } else if (typeof table.settings.horizontalPageBreakRepeat === \"string\" || typeof table.settings.horizontalPageBreakRepeat === \"number\") {\n                        horizontalPageBreakRepeat = [\n                            table.settings.horizontalPageBreakRepeat\n                        ];\n                    }\n                    // Code to repeat the given column in split pages\n                    horizontalPageBreakRepeat.forEach(function(field) {\n                        var col = table.columns.find(function(item) {\n                            return item.dataKey === field || item.index === field;\n                        });\n                        if (col && !repeatColumnsMap.has(col.index)) {\n                            repeatColumnsMap.set(col.index, true);\n                            colIndexes.push(col.index);\n                            columns.push(table.columns[col.index]);\n                            remainingWidth -= col.wrappedWidth;\n                        }\n                    });\n                    var first = true;\n                    var i = (_a = config === null || config === void 0 ? void 0 : config.start) !== null && _a !== void 0 ? _a : 0; // make sure couter is initiated outside the loop\n                    while(i < table.columns.length){\n                        // Prevent duplicates\n                        if (repeatColumnsMap.has(i)) {\n                            i++;\n                            continue;\n                        }\n                        var colWidth = table.columns[i].wrappedWidth;\n                        // Take at least one column even if it doesn't fit\n                        if (first || remainingWidth >= colWidth) {\n                            first = false;\n                            colIndexes.push(i);\n                            columns.push(table.columns[i]);\n                            remainingWidth -= colWidth;\n                        } else {\n                            break;\n                        }\n                        i++;\n                    }\n                    return {\n                        colIndexes: colIndexes,\n                        columns: columns,\n                        lastIndex: i - 1\n                    };\n                }\n                function calculateAllColumnsCanFitInPage(doc, table) {\n                    var allResults = [];\n                    for(var i = 0; i < table.columns.length; i++){\n                        var result = getColumnsCanFitInPage(doc, table, {\n                            start: i\n                        });\n                        if (result.columns.length) {\n                            allResults.push(result);\n                            i = result.lastIndex;\n                        }\n                    }\n                    return allResults;\n                }\n                exports1.calculateAllColumnsCanFitInPage = calculateAllColumnsCanFitInPage;\n            /***/ },\n            /***/ 324: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_114562__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.ellipsize = exports1.resizeColumns = exports1.calculateWidths = void 0;\n                var common_1 = __nested_webpack_require_114562__(420);\n                /**\n * Calculate the column widths\n */ function calculateWidths(doc, table) {\n                    calculate(doc, table);\n                    var resizableColumns = [];\n                    var initialTableWidth = 0;\n                    table.columns.forEach(function(column) {\n                        var customWidth = column.getMaxCustomCellWidth(table);\n                        if (customWidth) {\n                            // final column width\n                            column.width = customWidth;\n                        } else {\n                            // initial column width (will be resized)\n                            column.width = column.wrappedWidth;\n                            resizableColumns.push(column);\n                        }\n                        initialTableWidth += column.width;\n                    });\n                    // width difference that needs to be distributed\n                    var resizeWidth = table.getWidth(doc.pageSize().width) - initialTableWidth;\n                    // first resize attempt: with respect to minReadableWidth and minWidth\n                    if (resizeWidth) {\n                        resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {\n                            return Math.max(column.minReadableWidth, column.minWidth);\n                        });\n                    }\n                    // second resize attempt: ignore minReadableWidth but respect minWidth\n                    if (resizeWidth) {\n                        resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {\n                            return column.minWidth;\n                        });\n                    }\n                    resizeWidth = Math.abs(resizeWidth);\n                    if (!table.settings.horizontalPageBreak && resizeWidth > 0.1 / doc.scaleFactor()) {\n                        // Table can't get smaller due to custom-width or minWidth restrictions\n                        // We can't really do much here. Up to user to for example\n                        // reduce font size, increase page size or remove custom cell widths\n                        // to allow more columns to be reduced in size\n                        resizeWidth = resizeWidth < 1 ? resizeWidth : Math.round(resizeWidth);\n                        console.warn(\"Of the table content, \".concat(resizeWidth, \" units width could not fit page\"));\n                    }\n                    applyColSpans(table);\n                    fitContent(table, doc);\n                    applyRowSpans(table);\n                }\n                exports1.calculateWidths = calculateWidths;\n                function calculate(doc, table) {\n                    var sf = doc.scaleFactor();\n                    var horizontalPageBreak = table.settings.horizontalPageBreak;\n                    var availablePageWidth = (0, common_1.getPageAvailableWidth)(doc, table);\n                    table.allRows().forEach(function(row) {\n                        for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n                            var column = _a[_i];\n                            var cell = row.cells[column.index];\n                            if (!cell) continue;\n                            var hooks = table.hooks.didParseCell;\n                            table.callCellHooks(doc, hooks, cell, row, column, null);\n                            var padding = cell.padding(\"horizontal\");\n                            cell.contentWidth = (0, common_1.getStringWidth)(cell.text, cell.styles, doc) + padding;\n                            // Using [^\\S\\u00A0] instead of \\s ensures that we split the text on all\n                            // whitespace except non-breaking spaces (\\u00A0). We need to preserve\n                            // them in the split process to ensure correct word separation and width\n                            // calculation.\n                            var longestWordWidth = (0, common_1.getStringWidth)(cell.text.join(\" \").split(/[^\\S\\u00A0]+/), cell.styles, doc);\n                            cell.minReadableWidth = longestWordWidth + cell.padding(\"horizontal\");\n                            if (typeof cell.styles.cellWidth === \"number\") {\n                                cell.minWidth = cell.styles.cellWidth;\n                                cell.wrappedWidth = cell.styles.cellWidth;\n                            } else if (cell.styles.cellWidth === \"wrap\" || horizontalPageBreak === true) {\n                                // cell width should not be more than available page width\n                                if (cell.contentWidth > availablePageWidth) {\n                                    cell.minWidth = availablePageWidth;\n                                    cell.wrappedWidth = availablePageWidth;\n                                } else {\n                                    cell.minWidth = cell.contentWidth;\n                                    cell.wrappedWidth = cell.contentWidth;\n                                }\n                            } else {\n                                // auto\n                                var defaultMinWidth = 10 / sf;\n                                cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;\n                                cell.wrappedWidth = cell.contentWidth;\n                                if (cell.minWidth > cell.wrappedWidth) {\n                                    cell.wrappedWidth = cell.minWidth;\n                                }\n                            }\n                        }\n                    });\n                    table.allRows().forEach(function(row) {\n                        for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n                            var column = _a[_i];\n                            var cell = row.cells[column.index];\n                            // For now we ignore the minWidth and wrappedWidth of colspan cells when calculating colspan widths.\n                            // Could probably be improved upon however.\n                            if (cell && cell.colSpan === 1) {\n                                column.wrappedWidth = Math.max(column.wrappedWidth, cell.wrappedWidth);\n                                column.minWidth = Math.max(column.minWidth, cell.minWidth);\n                                column.minReadableWidth = Math.max(column.minReadableWidth, cell.minReadableWidth);\n                            } else {\n                                // Respect cellWidth set in columnStyles even if there is no cells for this column\n                                // or if the column only have colspan cells. Since the width of colspan cells\n                                // does not affect the width of columns, setting columnStyles cellWidth enables the\n                                // user to at least do it manually.\n                                // Note that this is not perfect for now since for example row and table styles are\n                                // not accounted for\n                                var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};\n                                var cellWidth = columnStyles.cellWidth || columnStyles.minCellWidth;\n                                if (cellWidth && typeof cellWidth === \"number\") {\n                                    column.minWidth = cellWidth;\n                                    column.wrappedWidth = cellWidth;\n                                }\n                            }\n                            if (cell) {\n                                // Make sure all columns get at least min width even though width calculations are not based on them\n                                if (cell.colSpan > 1 && !column.minWidth) {\n                                    column.minWidth = cell.minWidth;\n                                }\n                                if (cell.colSpan > 1 && !column.wrappedWidth) {\n                                    column.wrappedWidth = cell.minWidth;\n                                }\n                            }\n                        }\n                    });\n                }\n                /**\n * Distribute resizeWidth on passed resizable columns\n */ function resizeColumns(columns, resizeWidth, getMinWidth) {\n                    var initialResizeWidth = resizeWidth;\n                    var sumWrappedWidth = columns.reduce(function(acc, column) {\n                        return acc + column.wrappedWidth;\n                    }, 0);\n                    for(var i = 0; i < columns.length; i++){\n                        var column = columns[i];\n                        var ratio = column.wrappedWidth / sumWrappedWidth;\n                        var suggestedChange = initialResizeWidth * ratio;\n                        var suggestedWidth = column.width + suggestedChange;\n                        var minWidth = getMinWidth(column);\n                        var newWidth = suggestedWidth < minWidth ? minWidth : suggestedWidth;\n                        resizeWidth -= newWidth - column.width;\n                        column.width = newWidth;\n                    }\n                    resizeWidth = Math.round(resizeWidth * 1e10) / 1e10;\n                    // Run the resizer again if there's remaining width needs\n                    // to be distributed and there're columns that can be resized\n                    if (resizeWidth) {\n                        var resizableColumns = columns.filter(function(column) {\n                            return resizeWidth < 0 ? column.width > getMinWidth(column) // check if column can shrink\n                             : true; // check if column can grow\n                        });\n                        if (resizableColumns.length) {\n                            resizeWidth = resizeColumns(resizableColumns, resizeWidth, getMinWidth);\n                        }\n                    }\n                    return resizeWidth;\n                }\n                exports1.resizeColumns = resizeColumns;\n                function applyRowSpans(table) {\n                    var rowSpanCells = {};\n                    var colRowSpansLeft = 1;\n                    var all = table.allRows();\n                    for(var rowIndex = 0; rowIndex < all.length; rowIndex++){\n                        var row = all[rowIndex];\n                        for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n                            var column = _a[_i];\n                            var data = rowSpanCells[column.index];\n                            if (colRowSpansLeft > 1) {\n                                colRowSpansLeft--;\n                                delete row.cells[column.index];\n                            } else if (data) {\n                                data.cell.height += row.height;\n                                colRowSpansLeft = data.cell.colSpan;\n                                delete row.cells[column.index];\n                                data.left--;\n                                if (data.left <= 1) {\n                                    delete rowSpanCells[column.index];\n                                }\n                            } else {\n                                var cell = row.cells[column.index];\n                                if (!cell) {\n                                    continue;\n                                }\n                                cell.height = row.height;\n                                if (cell.rowSpan > 1) {\n                                    var remaining = all.length - rowIndex;\n                                    var left = cell.rowSpan > remaining ? remaining : cell.rowSpan;\n                                    rowSpanCells[column.index] = {\n                                        cell: cell,\n                                        left: left,\n                                        row: row\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n                function applyColSpans(table) {\n                    var all = table.allRows();\n                    for(var rowIndex = 0; rowIndex < all.length; rowIndex++){\n                        var row = all[rowIndex];\n                        var colSpanCell = null;\n                        var combinedColSpanWidth = 0;\n                        var colSpansLeft = 0;\n                        for(var columnIndex = 0; columnIndex < table.columns.length; columnIndex++){\n                            var column = table.columns[columnIndex];\n                            // Width and colspan\n                            colSpansLeft -= 1;\n                            if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {\n                                combinedColSpanWidth += column.width;\n                                delete row.cells[column.index];\n                            } else if (colSpanCell) {\n                                var cell = colSpanCell;\n                                delete row.cells[column.index];\n                                colSpanCell = null;\n                                cell.width = column.width + combinedColSpanWidth;\n                            } else {\n                                var cell = row.cells[column.index];\n                                if (!cell) continue;\n                                colSpansLeft = cell.colSpan;\n                                combinedColSpanWidth = 0;\n                                if (cell.colSpan > 1) {\n                                    colSpanCell = cell;\n                                    combinedColSpanWidth += column.width;\n                                    continue;\n                                }\n                                cell.width = column.width + combinedColSpanWidth;\n                            }\n                        }\n                    }\n                }\n                function fitContent(table, doc) {\n                    var rowSpanHeight = {\n                        count: 0,\n                        height: 0\n                    };\n                    for(var _i = 0, _a = table.allRows(); _i < _a.length; _i++){\n                        var row = _a[_i];\n                        for(var _b = 0, _c = table.columns; _b < _c.length; _b++){\n                            var column = _c[_b];\n                            var cell = row.cells[column.index];\n                            if (!cell) continue;\n                            doc.applyStyles(cell.styles, true);\n                            var textSpace = cell.width - cell.padding(\"horizontal\");\n                            if (cell.styles.overflow === \"linebreak\") {\n                                // Add one pt to textSpace to fix rounding error\n                                cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / doc.scaleFactor(), {\n                                    fontSize: cell.styles.fontSize\n                                });\n                            } else if (cell.styles.overflow === \"ellipsize\") {\n                                cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, \"...\");\n                            } else if (cell.styles.overflow === \"hidden\") {\n                                cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, \"\");\n                            } else if (typeof cell.styles.overflow === \"function\") {\n                                var result = cell.styles.overflow(cell.text, textSpace);\n                                if (typeof result === \"string\") {\n                                    cell.text = [\n                                        result\n                                    ];\n                                } else {\n                                    cell.text = result;\n                                }\n                            }\n                            cell.contentHeight = cell.getContentHeight(doc.scaleFactor(), doc.getLineHeightFactor());\n                            var realContentHeight = cell.contentHeight / cell.rowSpan;\n                            if (cell.rowSpan > 1 && rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan) {\n                                rowSpanHeight = {\n                                    height: realContentHeight,\n                                    count: cell.rowSpan\n                                };\n                            } else if (rowSpanHeight && rowSpanHeight.count > 0) {\n                                if (rowSpanHeight.height > realContentHeight) {\n                                    realContentHeight = rowSpanHeight.height;\n                                }\n                            }\n                            if (realContentHeight > row.height) {\n                                row.height = realContentHeight;\n                            }\n                        }\n                        rowSpanHeight.count--;\n                    }\n                }\n                function ellipsize(text, width, styles, doc, overflow) {\n                    return text.map(function(str) {\n                        return ellipsizeStr(str, width, styles, doc, overflow);\n                    });\n                }\n                exports1.ellipsize = ellipsize;\n                function ellipsizeStr(text, width, styles, doc, overflow) {\n                    var precision = 10000 * doc.scaleFactor();\n                    width = Math.ceil(width * precision) / precision;\n                    if (width >= (0, common_1.getStringWidth)(text, styles, doc)) {\n                        return text;\n                    }\n                    while(width < (0, common_1.getStringWidth)(text + overflow, styles, doc)){\n                        if (text.length <= 1) {\n                            break;\n                        }\n                        text = text.substring(0, text.length - 1);\n                    }\n                    return text.trim() + overflow;\n                }\n            /***/ },\n            /***/ 964: /***/ function(module1) {\n                if (typeof __WEBPACK_EXTERNAL_MODULE__964__ === \"undefined\") {\n                    var e = new Error(\"Cannot find module 'undefined'\");\n                    e.code = \"MODULE_NOT_FOUND\";\n                    throw e;\n                }\n                module1.exports = __WEBPACK_EXTERNAL_MODULE__964__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_133591__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_133591__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n        !function() {\n            var exports1 = __nested_webpack_exports__;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.Cell = exports1.Column = exports1.Row = exports1.Table = exports1.CellHookData = exports1.__drawTable = exports1.__createTable = exports1.applyPlugin = void 0;\n            var applyPlugin_1 = __nested_webpack_require_133591__(340);\n            var inputParser_1 = __nested_webpack_require_133591__(776);\n            var tableDrawer_1 = __nested_webpack_require_133591__(664);\n            var tableCalculator_1 = __nested_webpack_require_133591__(972);\n            var models_1 = __nested_webpack_require_133591__(260);\n            Object.defineProperty(exports1, \"Table\", {\n                enumerable: true,\n                get: function() {\n                    return models_1.Table;\n                }\n            });\n            var HookData_1 = __nested_webpack_require_133591__(172);\n            Object.defineProperty(exports1, \"CellHookData\", {\n                enumerable: true,\n                get: function() {\n                    return HookData_1.CellHookData;\n                }\n            });\n            var models_2 = __nested_webpack_require_133591__(260);\n            Object.defineProperty(exports1, \"Cell\", {\n                enumerable: true,\n                get: function() {\n                    return models_2.Cell;\n                }\n            });\n            Object.defineProperty(exports1, \"Column\", {\n                enumerable: true,\n                get: function() {\n                    return models_2.Column;\n                }\n            });\n            Object.defineProperty(exports1, \"Row\", {\n                enumerable: true,\n                get: function() {\n                    return models_2.Row;\n                }\n            });\n            // export { applyPlugin } didn't export applyPlugin\n            // to index.d.ts for some reason\n            function applyPlugin(jsPDF) {\n                (0, applyPlugin_1.default)(jsPDF);\n            }\n            exports1.applyPlugin = applyPlugin;\n            function autoTable(d, options) {\n                var input = (0, inputParser_1.parseInput)(d, options);\n                var table = (0, tableCalculator_1.createTable)(d, input);\n                (0, tableDrawer_1.drawTable)(d, table);\n            }\n            // Experimental export\n            function __createTable(d, options) {\n                var input = (0, inputParser_1.parseInput)(d, options);\n                return (0, tableCalculator_1.createTable)(d, input);\n            }\n            exports1.__createTable = __createTable;\n            function __drawTable(d, table) {\n                (0, tableDrawer_1.drawTable)(d, table);\n            }\n            exports1.__drawTable = __drawTable;\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-var-requires\n                var jsPDF = __nested_webpack_require_133591__(964);\n                // Webpack imported jspdf instead of jsPDF for some reason\n                // while it seemed to work everywhere else.\n                if (jsPDF.jsPDF) jsPDF = jsPDF.jsPDF;\n                applyPlugin(jsPDF);\n            } catch (error) {\n            // Importing jspdf in nodejs environments does not work as of jspdf\n            // 1.5.3 so we need to silence potential errors to support using for example\n            // the nodejs jspdf dist files with the exported applyPlugin\n            }\n            exports1[\"default\"] = autoTable;\n        }();\n        /******/ return __nested_webpack_exports__;\n    /******/ }();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNwZGYtYXV0b3RhYmxlL2Rpc3QvanNwZGYucGx1Z2luLmF1dG90YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUNBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUyxTQUFTRztRQUFzQyxJQUFJO1lBQUUsT0FBT0MsbUJBQU9BLENBQUMsOERBQU87UUFBRyxFQUFFLE9BQU1DLEdBQUcsQ0FBQztJQUFFO1NBQ2xILGFBS0o7QUFDRixHQUFHLE9BQU9LLGVBQWUsY0FBY0EsYUFBYSxPQUFPLElBQUksS0FBSyxjQUFjLElBQUksR0FBRyxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLE9BQU9DLFNBQVMsY0FBY0EsT0FBT0MsUUFBUyxTQUFTQyxnQ0FBZ0M7SUFDek4sT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7WUFFckMsR0FBRyxHQUFHLEtBQ04sR0FBRyxHQUFJLFNBQVNDLHVCQUF1QixFQUFFZixRQUFPO2dCQUdoRCxJQUFJZ0IsWUFBWSxJQUFLLElBQUksSUFBSSxDQUFDQSxTQUFTLElBQUs7b0JBQ3hDLElBQUlDLGdCQUFnQixTQUFVQyxDQUFDLEVBQUVDLENBQUM7d0JBQzlCRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFDaEM7NEJBQUVDLFdBQVcsRUFBRTt3QkFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQzs0QkFBSUQsRUFBRUksU0FBUyxHQUFHSDt3QkFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7NEJBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7d0JB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IndlYnBhY2s6Ly9ob3N0ZWwtbWFuYWdlbWVudC1uZXh0anMvLi9ub2RlX21vZHVsZXMvanNwZGYtYXV0b3RhYmxlL2Rpc3QvanNwZGYucGx1Z2luLmF1dG90YWJsZS5qcz85NDUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogXG4gKiAgICAgICAgICAgICAgIGpzUERGIEF1dG9UYWJsZSBwbHVnaW4gdjMuOC40XG4gKlxuICogICAgICAgICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMjQgU2ltb24gQmVuZ3Rzc29uLCBodHRwczovL2dpdGh1Yi5jb20vc2ltb25iZW5ndHNzb24vanNQREYtQXV0b1RhYmxlXG4gKiAgICAgICAgICAgICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqICAgICAgICAgICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KChmdW5jdGlvbiB3ZWJwYWNrTG9hZE9wdGlvbmFsRXh0ZXJuYWxNb2R1bGUoKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKFwianNwZGZcIik7IH0gY2F0Y2goZSkge30gfSgpKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJqc3BkZlwiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeSgoZnVuY3Rpb24gd2VicGFja0xvYWRPcHRpb25hbEV4dGVybmFsTW9kdWxlKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZShcImpzcGRmXCIpOyB9IGNhdGNoKGUpIHt9IH0oKSkpIDogZmFjdG9yeShyb290W1wianNwZGZcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJyA/IHRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiBnbG9iYWwgLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX185NjRfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyAxNzI6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNlbGxIb29rRGF0YSA9IGV4cG9ydHMuSG9va0RhdGEgPSB2b2lkIDA7XG52YXIgSG9va0RhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSG9va0RhdGEoZG9jLCB0YWJsZSwgY3Vyc29yKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyID0gdGFibGUucGFnZU51bWJlcjtcbiAgICAgICAgdGhpcy5wYWdlQ291bnQgPSB0aGlzLnBhZ2VOdW1iZXI7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB0YWJsZS5zZXR0aW5ncztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jLmdldERvY3VtZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBIb29rRGF0YTtcbn0oKSk7XG5leHBvcnRzLkhvb2tEYXRhID0gSG9va0RhdGE7XG52YXIgQ2VsbEhvb2tEYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDZWxsSG9va0RhdGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2VsbEhvb2tEYXRhKGRvYywgdGFibGUsIGNlbGwsIHJvdywgY29sdW1uLCBjdXJzb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jLCB0YWJsZSwgY3Vyc29yKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jZWxsID0gY2VsbDtcbiAgICAgICAgX3RoaXMucm93ID0gcm93O1xuICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIF90aGlzLnNlY3Rpb24gPSByb3cuc2VjdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2VsbEhvb2tEYXRhO1xufShIb29rRGF0YSkpO1xuZXhwb3J0cy5DZWxsSG9va0RhdGEgPSBDZWxsSG9va0RhdGE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0MDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xudmFyIGh0bWxQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgYXV0b1RhYmxlVGV4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpO1xudmFyIGRvY3VtZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDQpO1xudmFyIGlucHV0UGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3Nik7XG52YXIgdGFibGVEcmF3ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjY0KTtcbnZhciB0YWJsZUNhbGN1bGF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTcyKTtcbmZ1bmN0aW9uIGRlZmF1bHRfMShqc1BERikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAganNQREYuQVBJLmF1dG9UYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZSBvZiBkZXByZWNhdGVkIGF1dG9UYWJsZSBpbml0aWF0aW9uJyk7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnc1syXSB8fCB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuY29sdW1ucyA9IGFyZ3NbMF07XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBhcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dCA9ICgwLCBpbnB1dFBhcnNlcl8xLnBhcnNlSW5wdXQpKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgdGFibGUgPSAoMCwgdGFibGVDYWxjdWxhdG9yXzEuY3JlYXRlVGFibGUpKHRoaXMsIGlucHV0KTtcbiAgICAgICAgKDAsIHRhYmxlRHJhd2VyXzEuZHJhd1RhYmxlKSh0aGlzLCB0YWJsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gQXNzaWduIGZhbHNlIHRvIGVuYWJsZSBgZG9jLmxhc3RBdXRvVGFibGUuZmluYWxZIHx8IDQwYCBzdWdhclxuICAgIGpzUERGLkFQSS5sYXN0QXV0b1RhYmxlID0gZmFsc2U7XG4gICAganNQREYuQVBJLnByZXZpb3VzQXV0b1RhYmxlID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWQgaW4gdjNcbiAgICBqc1BERi5BUEkuYXV0b1RhYmxlLnByZXZpb3VzID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWQgaW4gdjNcbiAgICBqc1BERi5BUEkuYXV0b1RhYmxlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBzdHlsZXMpIHtcbiAgICAgICAgKDAsIGF1dG9UYWJsZVRleHRfMS5kZWZhdWx0KSh0ZXh0LCB4LCB5LCBzdHlsZXMsIHRoaXMpO1xuICAgIH07XG4gICAganNQREYuQVBJLmF1dG9UYWJsZVNldERlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIGRvY3VtZW50SGFuZGxlcl8xLkRvY0hhbmRsZXIuc2V0RGVmYXVsdHMoZGVmYXVsdHMsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGpzUERGLmF1dG9UYWJsZVNldERlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBkb2MpIHtcbiAgICAgICAgZG9jdW1lbnRIYW5kbGVyXzEuRG9jSGFuZGxlci5zZXREZWZhdWx0cyhkZWZhdWx0cywgZG9jKTtcbiAgICB9O1xuICAgIGpzUERGLkFQSS5hdXRvVGFibGVIdG1sVG9Kc29uID0gZnVuY3Rpb24gKHRhYmxlRWxlbSwgaW5jbHVkZUhpZGRlbkVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGluY2x1ZGVIaWRkZW5FbGVtZW50cyA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIaWRkZW5FbGVtZW50cyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHJ1biBhdXRvVGFibGVIdG1sVG9Kc29uIGluIG5vbiBicm93c2VyIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gbmV3IGRvY3VtZW50SGFuZGxlcl8xLkRvY0hhbmRsZXIodGhpcyk7XG4gICAgICAgIHZhciBfYiA9ICgwLCBodG1sUGFyc2VyXzEucGFyc2VIdG1sKShkb2MsIHRhYmxlRWxlbSwgd2luZG93LCBpbmNsdWRlSGlkZGVuRWxlbWVudHMsIGZhbHNlKSwgaGVhZCA9IF9iLmhlYWQsIGJvZHkgPSBfYi5ib2R5O1xuICAgICAgICB2YXIgY29sdW1ucyA9ICgoX2EgPSBoZWFkWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmNvbnRlbnQ7IH0pKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgY29sdW1uczogY29sdW1ucywgcm93czogYm9keSwgZGF0YTogYm9keSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBqc1BERi5BUEkuYXV0b1RhYmxlRW5kUG9zWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVXNlIG9mIGRlcHJlY2F0ZWQgZnVuY3Rpb246IGF1dG9UYWJsZUVuZFBvc1kuIFVzZSBkb2MubGFzdEF1dG9UYWJsZS5maW5hbFkgaW5zdGVhZC4nKTtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLmxhc3RBdXRvVGFibGU7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuZmluYWxZKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldi5maW5hbFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBqc1BERi5BUEkuYXV0b1RhYmxlQWRkUGFnZUNvbnRlbnQgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdVc2Ugb2YgZGVwcmVjYXRlZCBmdW5jdGlvbjogYXV0b1RhYmxlQWRkUGFnZUNvbnRlbnQuIFVzZSBqc1BERi5hdXRvVGFibGVTZXREZWZhdWx0cyh7ZGlkRHJhd1BhZ2U6ICgpID0+IHt9fSkgaW5zdGVhZC4nKTtcbiAgICAgICAgaWYgKCFqc1BERi5BUEkuYXV0b1RhYmxlLmdsb2JhbERlZmF1bHRzKSB7XG4gICAgICAgICAgICBqc1BERi5BUEkuYXV0b1RhYmxlLmdsb2JhbERlZmF1bHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAganNQREYuQVBJLmF1dG9UYWJsZS5nbG9iYWxEZWZhdWx0cy5hZGRQYWdlQ29udGVudCA9IGhvb2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBqc1BERi5BUEkuYXV0b1RhYmxlQWRkUGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVXNlIG9mIGRlcHJlY2F0ZWQgZnVuY3Rpb246IGF1dG9UYWJsZUFkZFBhZ2UuIFVzZSBkb2MuYWRkUGFnZSgpJyk7XG4gICAgICAgIHRoaXMuYWRkUGFnZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0XzE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEzNjpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuLyoqXG4gKiBJbXByb3ZlZCB0ZXh0IGZ1bmN0aW9uIHdpdGggaGFsaWduIGFuZCB2YWxpZ24gc3VwcG9ydFxuICogSW5zcGlyYXRpb24gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yODMyNzUxMC9hbGlnbi10ZXh0LXJpZ2h0LXVzaW5nLWpzcGRmLzI4NDMzMTEzIzI4NDMzMTEzXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRfMSh0ZXh0LCB4LCB5LCBzdHlsZXMsIGRvYykge1xuICAgIHN0eWxlcyA9IHN0eWxlcyB8fCB7fTtcbiAgICB2YXIgUEhZU0lDQUxfTElORV9IRUlHSFQgPSAxLjE1O1xuICAgIHZhciBrID0gZG9jLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHZhciBmb250U2l6ZSA9IGRvYy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpIC8gaztcbiAgICB2YXIgbGluZUhlaWdodEZhY3RvciA9IGRvYy5nZXRMaW5lSGVpZ2h0RmFjdG9yXG4gICAgICAgID8gZG9jLmdldExpbmVIZWlnaHRGYWN0b3IoKVxuICAgICAgICA6IFBIWVNJQ0FMX0xJTkVfSEVJR0hUO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gZm9udFNpemUgKiBsaW5lSGVpZ2h0RmFjdG9yO1xuICAgIHZhciBzcGxpdFJlZ2V4ID0gL1xcclxcbnxcXHJ8XFxuL2c7XG4gICAgdmFyIHNwbGl0VGV4dCA9ICcnO1xuICAgIHZhciBsaW5lQ291bnQgPSAxO1xuICAgIGlmIChzdHlsZXMudmFsaWduID09PSAnbWlkZGxlJyB8fFxuICAgICAgICBzdHlsZXMudmFsaWduID09PSAnYm90dG9tJyB8fFxuICAgICAgICBzdHlsZXMuaGFsaWduID09PSAnY2VudGVyJyB8fFxuICAgICAgICBzdHlsZXMuaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHNwbGl0VGV4dCA9IHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IHRleHQuc3BsaXQoc3BsaXRSZWdleCkgOiB0ZXh0O1xuICAgICAgICBsaW5lQ291bnQgPSBzcGxpdFRleHQubGVuZ3RoIHx8IDE7XG4gICAgfVxuICAgIC8vIEFsaWduIHRoZSB0b3BcbiAgICB5ICs9IGZvbnRTaXplICogKDIgLSBQSFlTSUNBTF9MSU5FX0hFSUdIVCk7XG4gICAgaWYgKHN0eWxlcy52YWxpZ24gPT09ICdtaWRkbGUnKVxuICAgICAgICB5IC09IChsaW5lQ291bnQgLyAyKSAqIGxpbmVIZWlnaHQ7XG4gICAgZWxzZSBpZiAoc3R5bGVzLnZhbGlnbiA9PT0gJ2JvdHRvbScpXG4gICAgICAgIHkgLT0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICBpZiAoc3R5bGVzLmhhbGlnbiA9PT0gJ2NlbnRlcicgfHwgc3R5bGVzLmhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB2YXIgYWxpZ25TaXplID0gZm9udFNpemU7XG4gICAgICAgIGlmIChzdHlsZXMuaGFsaWduID09PSAnY2VudGVyJylcbiAgICAgICAgICAgIGFsaWduU2l6ZSAqPSAwLjU7XG4gICAgICAgIGlmIChzcGxpdFRleHQgJiYgbGluZUNvdW50ID49IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlMaW5lID0gMDsgaUxpbmUgPCBzcGxpdFRleHQubGVuZ3RoOyBpTGluZSsrKSB7XG4gICAgICAgICAgICAgICAgZG9jLnRleHQoc3BsaXRUZXh0W2lMaW5lXSwgeCAtIGRvYy5nZXRTdHJpbmdVbml0V2lkdGgoc3BsaXRUZXh0W2lMaW5lXSkgKiBhbGlnblNpemUsIHkpO1xuICAgICAgICAgICAgICAgIHkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgeCAtPSBkb2MuZ2V0U3RyaW5nVW5pdFdpZHRoKHRleHQpICogYWxpZ25TaXplO1xuICAgIH1cbiAgICBpZiAoc3R5bGVzLmhhbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgIGRvYy50ZXh0KHRleHQsIHgsIHksIHtcbiAgICAgICAgICAgIG1heFdpZHRoOiBzdHlsZXMubWF4V2lkdGggfHwgMTAwLFxuICAgICAgICAgICAgYWxpZ246ICdqdXN0aWZ5JyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb2MudGV4dCh0ZXh0LCB4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYztcbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZGVmYXVsdF8xO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuZ2V0UGFnZUF2YWlsYWJsZVdpZHRoID0gZXhwb3J0cy5wYXJzZVNwYWNpbmcgPSBleHBvcnRzLmdldEZpbGxTdHlsZSA9IGV4cG9ydHMuYWRkVGFibGVCb3JkZXIgPSBleHBvcnRzLmdldFN0cmluZ1dpZHRoID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0U3RyaW5nV2lkdGgodGV4dCwgc3R5bGVzLCBkb2MpIHtcbiAgICBkb2MuYXBwbHlTdHlsZXMoc3R5bGVzLCB0cnVlKTtcbiAgICB2YXIgdGV4dEFyciA9IEFycmF5LmlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICAgIHZhciB3aWRlc3RMaW5lV2lkdGggPSB0ZXh0QXJyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGRvYy5nZXRUZXh0V2lkdGgodGV4dCk7IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGgubWF4KGEsIGIpOyB9LCAwKTtcbiAgICByZXR1cm4gd2lkZXN0TGluZVdpZHRoO1xufVxuZXhwb3J0cy5nZXRTdHJpbmdXaWR0aCA9IGdldFN0cmluZ1dpZHRoO1xuZnVuY3Rpb24gYWRkVGFibGVCb3JkZXIoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvcikge1xuICAgIHZhciBsaW5lV2lkdGggPSB0YWJsZS5zZXR0aW5ncy50YWJsZUxpbmVXaWR0aDtcbiAgICB2YXIgbGluZUNvbG9yID0gdGFibGUuc2V0dGluZ3MudGFibGVMaW5lQ29sb3I7XG4gICAgZG9jLmFwcGx5U3R5bGVzKHsgbGluZVdpZHRoOiBsaW5lV2lkdGgsIGxpbmVDb2xvcjogbGluZUNvbG9yIH0pO1xuICAgIHZhciBmaWxsU3R5bGUgPSBnZXRGaWxsU3R5bGUobGluZVdpZHRoLCBmYWxzZSk7XG4gICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgICBkb2MucmVjdChzdGFydFBvcy54LCBzdGFydFBvcy55LCB0YWJsZS5nZXRXaWR0aChkb2MucGFnZVNpemUoKS53aWR0aCksIGN1cnNvci55IC0gc3RhcnRQb3MueSwgZmlsbFN0eWxlKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZFRhYmxlQm9yZGVyID0gYWRkVGFibGVCb3JkZXI7XG5mdW5jdGlvbiBnZXRGaWxsU3R5bGUobGluZVdpZHRoLCBmaWxsQ29sb3IpIHtcbiAgICB2YXIgZHJhd0xpbmUgPSBsaW5lV2lkdGggPiAwO1xuICAgIHZhciBkcmF3QmFja2dyb3VuZCA9IGZpbGxDb2xvciB8fCBmaWxsQ29sb3IgPT09IDA7XG4gICAgaWYgKGRyYXdMaW5lICYmIGRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJldHVybiAnREYnOyAvLyBGaWxsIHRoZW4gc3Ryb2tlXG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYXdMaW5lKSB7XG4gICAgICAgIHJldHVybiAnUyc7IC8vIE9ubHkgc3Ryb2tlICh0cmFuc3BhcmVudCBiYWNrZ3JvdW5kKVxuICAgIH1cbiAgICBlbHNlIGlmIChkcmF3QmFja2dyb3VuZCkge1xuICAgICAgICByZXR1cm4gJ0YnOyAvLyBPbmx5IGZpbGwsIG5vIHN0cm9rZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGaWxsU3R5bGUgPSBnZXRGaWxsU3R5bGU7XG5mdW5jdGlvbiBwYXJzZVNwYWNpbmcodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB2YWx1ZSA9IHZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHZhbHVlWzFdLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogdmFsdWVbMl0sXG4gICAgICAgICAgICAgICAgbGVmdDogdmFsdWVbM10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICBib3R0b206IHZhbHVlWzJdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHZhbHVlWzFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICByaWdodDogdmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgYm90dG9tOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS52ZXJ0aWNhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlLnRvcCA9IHZhbHVlLnZlcnRpY2FsO1xuICAgICAgICAgICAgdmFsdWUuYm90dG9tID0gdmFsdWUudmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5ob3Jpem9udGFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUucmlnaHQgPSB2YWx1ZS5ob3Jpem9udGFsO1xuICAgICAgICAgICAgdmFsdWUubGVmdCA9IHZhbHVlLmhvcml6b250YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IChfYSA9IHZhbHVlLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIHRvcDogKF9iID0gdmFsdWUudG9wKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICByaWdodDogKF9jID0gdmFsdWUucmlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgIGJvdHRvbTogKF9kID0gdmFsdWUuYm90dG9tKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0b3A6IHZhbHVlLCByaWdodDogdmFsdWUsIGJvdHRvbTogdmFsdWUsIGxlZnQ6IHZhbHVlIH07XG59XG5leHBvcnRzLnBhcnNlU3BhY2luZyA9IHBhcnNlU3BhY2luZztcbmZ1bmN0aW9uIGdldFBhZ2VBdmFpbGFibGVXaWR0aChkb2MsIHRhYmxlKSB7XG4gICAgdmFyIG1hcmdpbnMgPSBwYXJzZVNwYWNpbmcodGFibGUuc2V0dGluZ3MubWFyZ2luLCAwKTtcbiAgICByZXR1cm4gZG9jLnBhZ2VTaXplKCkud2lkdGggLSAobWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodCk7XG59XG5leHBvcnRzLmdldFBhZ2VBdmFpbGFibGVXaWR0aCA9IGdldFBhZ2VBdmFpbGFibGVXaWR0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzk2OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5nZXRUaGVtZSA9IGV4cG9ydHMuZGVmYXVsdFN0eWxlcyA9IGV4cG9ydHMuSHRtbFJvd0lucHV0ID0gdm9pZCAwO1xudmFyIEh0bWxSb3dJbnB1dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHRtbFJvd0lucHV0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0bWxSb3dJbnB1dChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSHRtbFJvd0lucHV0O1xufShBcnJheSkpO1xuZXhwb3J0cy5IdG1sUm93SW5wdXQgPSBIdG1sUm93SW5wdXQ7XG4vLyBCYXNlIHN0eWxlIGZvciBhbGwgdGhlbWVzXG5mdW5jdGlvbiBkZWZhdWx0U3R5bGVzKHNjYWxlRmFjdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9udDogJ2hlbHZldGljYScsIC8vIGhlbHZldGljYSwgdGltZXMsIGNvdXJpZXJcbiAgICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJywgLy8gbm9ybWFsLCBib2xkLCBpdGFsaWMsIGJvbGRpdGFsaWNcbiAgICAgICAgb3ZlcmZsb3c6ICdsaW5lYnJlYWsnLCAvLyBsaW5lYnJlYWssIGVsbGlwc2l6ZSwgdmlzaWJsZSBvciBoaWRkZW5cbiAgICAgICAgZmlsbENvbG9yOiBmYWxzZSwgLy8gRWl0aGVyIGZhbHNlIGZvciB0cmFuc3BhcmVudCwgcmJnIGFycmF5IGUuZy4gWzI1NSwgMjU1LCAyNTVdIG9yIGdyYXkgbGV2ZWwgZS5nIDIwMFxuICAgICAgICB0ZXh0Q29sb3I6IDIwLFxuICAgICAgICBoYWxpZ246ICdsZWZ0JywgLy8gbGVmdCwgY2VudGVyLCByaWdodCwganVzdGlmeVxuICAgICAgICB2YWxpZ246ICd0b3AnLCAvLyB0b3AsIG1pZGRsZSwgYm90dG9tXG4gICAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgICAgY2VsbFBhZGRpbmc6IDUgLyBzY2FsZUZhY3RvciwgLy8gbnVtYmVyIG9yIHt0b3AsbGVmdCxyaWdodCxsZWZ0LHZlcnRpY2FsLGhvcml6b250YWx9XG4gICAgICAgIGxpbmVDb2xvcjogMjAwLFxuICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgIGNlbGxXaWR0aDogJ2F1dG8nLCAvLyAnYXV0byd8J3dyYXAnfG51bWJlclxuICAgICAgICBtaW5DZWxsSGVpZ2h0OiAwLFxuICAgICAgICBtaW5DZWxsV2lkdGg6IDAsXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdFN0eWxlcyA9IGRlZmF1bHRTdHlsZXM7XG5mdW5jdGlvbiBnZXRUaGVtZShuYW1lKSB7XG4gICAgdmFyIHRoZW1lcyA9IHtcbiAgICAgICAgc3RyaXBlZDoge1xuICAgICAgICAgICAgdGFibGU6IHsgZmlsbENvbG9yOiAyNTUsIHRleHRDb2xvcjogODAsIGZvbnRTdHlsZTogJ25vcm1hbCcgfSxcbiAgICAgICAgICAgIGhlYWQ6IHsgdGV4dENvbG9yOiAyNTUsIGZpbGxDb2xvcjogWzQxLCAxMjgsIDE4NV0sIGZvbnRTdHlsZTogJ2JvbGQnIH0sXG4gICAgICAgICAgICBib2R5OiB7fSxcbiAgICAgICAgICAgIGZvb3Q6IHsgdGV4dENvbG9yOiAyNTUsIGZpbGxDb2xvcjogWzQxLCAxMjgsIDE4NV0sIGZvbnRTdHlsZTogJ2JvbGQnIH0sXG4gICAgICAgICAgICBhbHRlcm5hdGVSb3c6IHsgZmlsbENvbG9yOiAyNDUgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IDI1NSxcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDgwLFxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwLjEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVhZDoge1xuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogMjU1LFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogWzI2LCAxODgsIDE1Nl0sXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHt9LFxuICAgICAgICAgICAgZm9vdDoge1xuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogMjU1LFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogWzI2LCAxODgsIDE1Nl0sXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsdGVybmF0ZVJvdzoge30sXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWluOiB7XG4gICAgICAgICAgICBoZWFkOiB7IGZvbnRTdHlsZTogJ2JvbGQnIH0sXG4gICAgICAgICAgICBmb290OiB7IGZvbnRTdHlsZTogJ2JvbGQnIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gdGhlbWVzW25hbWVdO1xufVxuZXhwb3J0cy5nZXRUaGVtZSA9IGdldFRoZW1lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MDM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMucGFyc2VDc3MgPSB2b2lkIDA7XG4vLyBMaW1pdGF0aW9uc1xuLy8gLSBObyBzdXBwb3J0IGZvciBib3JkZXIgc3BhY2luZ1xuLy8gLSBObyBzdXBwb3J0IGZvciB0cmFuc3BhcmVuY3lcbnZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIwKTtcbmZ1bmN0aW9uIHBhcnNlQ3NzKHN1cHBvcnRlZEZvbnRzLCBlbGVtZW50LCBzY2FsZUZhY3Rvciwgc3R5bGUsIHdpbmRvdykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgcHhTY2FsZUZhY3RvciA9IDk2IC8gNzI7XG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHBhcnNlQ29sb3IoZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pWydiYWNrZ3JvdW5kQ29sb3InXTtcbiAgICB9KTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yICE9IG51bGwpXG4gICAgICAgIHJlc3VsdC5maWxsQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgdmFyIHRleHRDb2xvciA9IHBhcnNlQ29sb3IoZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pWydjb2xvciddO1xuICAgIH0pO1xuICAgIGlmICh0ZXh0Q29sb3IgIT0gbnVsbClcbiAgICAgICAgcmVzdWx0LnRleHRDb2xvciA9IHRleHRDb2xvcjtcbiAgICB2YXIgcGFkZGluZyA9IHBhcnNlUGFkZGluZyhzdHlsZSwgc2NhbGVGYWN0b3IpO1xuICAgIGlmIChwYWRkaW5nKVxuICAgICAgICByZXN1bHQuY2VsbFBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHZhciBib3JkZXJDb2xvclNpZGUgPSAnYm9yZGVyVG9wQ29sb3InO1xuICAgIHZhciBmaW5hbFNjYWxlRmFjdG9yID0gcHhTY2FsZUZhY3RvciAqIHNjYWxlRmFjdG9yO1xuICAgIHZhciBidHcgPSBzdHlsZS5ib3JkZXJUb3BXaWR0aDtcbiAgICBpZiAoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPT09IGJ0dyAmJlxuICAgICAgICBzdHlsZS5ib3JkZXJSaWdodFdpZHRoID09PSBidHcgJiZcbiAgICAgICAgc3R5bGUuYm9yZGVyTGVmdFdpZHRoID09PSBidHcpIHtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHBhcnNlRmxvYXQoYnR3KSB8fCAwKSAvIGZpbmFsU2NhbGVGYWN0b3I7XG4gICAgICAgIGlmIChib3JkZXJXaWR0aClcbiAgICAgICAgICAgIHJlc3VsdC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5saW5lV2lkdGggPSB7XG4gICAgICAgICAgICB0b3A6IChwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwKSAvIGZpbmFsU2NhbGVGYWN0b3IsXG4gICAgICAgICAgICByaWdodDogKHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgfHwgMCkgLyBmaW5hbFNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgYm90dG9tOiAocGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCkgfHwgMCkgLyBmaW5hbFNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgbGVmdDogKHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwKSAvIGZpbmFsU2NhbGVGYWN0b3IsXG4gICAgICAgIH07XG4gICAgICAgIC8vIENob29zZSBib3JkZXIgY29sb3Igb2YgZmlyc3QgYXZhaWxhYmxlIHNpZGVcbiAgICAgICAgLy8gY291bGQgYmUgaW1wcm92ZWQgYnkgc3VwcG9ydGluZyBvYmplY3QgYXMgbGluZUNvbG9yXG4gICAgICAgIGlmICghcmVzdWx0LmxpbmVXaWR0aC50b3ApIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGluZVdpZHRoLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3JTaWRlID0gJ2JvcmRlclJpZ2h0Q29sb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmxpbmVXaWR0aC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvclNpZGUgPSAnYm9yZGVyQm90dG9tQ29sb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmxpbmVXaWR0aC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3JTaWRlID0gJ2JvcmRlckxlZnRDb2xvcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGJvcmRlckNvbG9yID0gcGFyc2VDb2xvcihlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSlbYm9yZGVyQ29sb3JTaWRlXTtcbiAgICB9KTtcbiAgICBpZiAoYm9yZGVyQ29sb3IgIT0gbnVsbClcbiAgICAgICAgcmVzdWx0LmxpbmVDb2xvciA9IGJvcmRlckNvbG9yO1xuICAgIHZhciBhY2NlcHRlZCA9IFsnbGVmdCcsICdyaWdodCcsICdjZW50ZXInLCAnanVzdGlmeSddO1xuICAgIGlmIChhY2NlcHRlZC5pbmRleE9mKHN0eWxlLnRleHRBbGlnbikgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5oYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGFjY2VwdGVkID0gWydtaWRkbGUnLCAnYm90dG9tJywgJ3RvcCddO1xuICAgIGlmIChhY2NlcHRlZC5pbmRleE9mKHN0eWxlLnZlcnRpY2FsQWxpZ24pICE9PSAtMSkge1xuICAgICAgICByZXN1bHQudmFsaWduID0gc3R5bGUudmVydGljYWxBbGlnbjtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHBhcnNlSW50KHN0eWxlLmZvbnRTaXplIHx8ICcnKTtcbiAgICBpZiAoIWlzTmFOKHJlcykpXG4gICAgICAgIHJlc3VsdC5mb250U2l6ZSA9IHJlcyAvIHB4U2NhbGVGYWN0b3I7XG4gICAgdmFyIGZvbnRTdHlsZSA9IHBhcnNlRm9udFN0eWxlKHN0eWxlKTtcbiAgICBpZiAoZm9udFN0eWxlKVxuICAgICAgICByZXN1bHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIHZhciBmb250ID0gKHN0eWxlLmZvbnRGYW1pbHkgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHN1cHBvcnRlZEZvbnRzLmluZGV4T2YoZm9udCkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5mb250ID0gZm9udDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2VDc3MgPSBwYXJzZUNzcztcbmZ1bmN0aW9uIHBhcnNlRm9udFN0eWxlKHN0eWxlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGlmIChzdHlsZS5mb250V2VpZ2h0ID09PSAnYm9sZCcgfHxcbiAgICAgICAgc3R5bGUuZm9udFdlaWdodCA9PT0gJ2JvbGRlcicgfHxcbiAgICAgICAgcGFyc2VJbnQoc3R5bGUuZm9udFdlaWdodCkgPj0gNzAwKSB7XG4gICAgICAgIHJlcyA9ICdib2xkJztcbiAgICB9XG4gICAgaWYgKHN0eWxlLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYycgfHwgc3R5bGUuZm9udFN0eWxlID09PSAnb2JsaXF1ZScpIHtcbiAgICAgICAgcmVzICs9ICdpdGFsaWMnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VDb2xvcihlbGVtZW50LCBzdHlsZUdldHRlcikge1xuICAgIHZhciBjc3NDb2xvciA9IHJlYWxDb2xvcihlbGVtZW50LCBzdHlsZUdldHRlcik7XG4gICAgaWYgKCFjc3NDb2xvcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIHJnYmEgPSBjc3NDb2xvci5tYXRjaCgvXnJnYmE/XFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSg/OixcXHMqKFxcZCpcXC4/XFxkKikpP1xcKSQvKTtcbiAgICBpZiAoIXJnYmEgfHwgIUFycmF5LmlzQXJyYXkocmdiYSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjb2xvciA9IFtcbiAgICAgICAgcGFyc2VJbnQocmdiYVsxXSksXG4gICAgICAgIHBhcnNlSW50KHJnYmFbMl0pLFxuICAgICAgICBwYXJzZUludChyZ2JhWzNdKSxcbiAgICBdO1xuICAgIHZhciBhbHBoYSA9IHBhcnNlSW50KHJnYmFbNF0pO1xuICAgIGlmIChhbHBoYSA9PT0gMCB8fCBpc05hTihjb2xvclswXSkgfHwgaXNOYU4oY29sb3JbMV0pIHx8IGlzTmFOKGNvbG9yWzJdKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xufVxuZnVuY3Rpb24gcmVhbENvbG9yKGVsZW0sIHN0eWxlR2V0dGVyKSB7XG4gICAgdmFyIGJnID0gc3R5bGVHZXR0ZXIoZWxlbSk7XG4gICAgaWYgKGJnID09PSAncmdiYSgwLCAwLCAwLCAwKScgfHxcbiAgICAgICAgYmcgPT09ICd0cmFuc3BhcmVudCcgfHxcbiAgICAgICAgYmcgPT09ICdpbml0aWFsJyB8fFxuICAgICAgICBiZyA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgIGlmIChlbGVtLnBhcmVudEVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWxDb2xvcihlbGVtLnBhcmVudEVsZW1lbnQsIHN0eWxlR2V0dGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiZztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVBhZGRpbmcoc3R5bGUsIHNjYWxlRmFjdG9yKSB7XG4gICAgdmFyIHZhbCA9IFtcbiAgICAgICAgc3R5bGUucGFkZGluZ1RvcCxcbiAgICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0LFxuICAgICAgICBzdHlsZS5wYWRkaW5nQm90dG9tLFxuICAgICAgICBzdHlsZS5wYWRkaW5nTGVmdCxcbiAgICBdO1xuICAgIHZhciBweFNjYWxlRmFjdG9yID0gOTYgLyAoNzIgLyBzY2FsZUZhY3Rvcik7XG4gICAgdmFyIGxpbmVQYWRkaW5nID0gKHBhcnNlSW50KHN0eWxlLmxpbmVIZWlnaHQpIC0gcGFyc2VJbnQoc3R5bGUuZm9udFNpemUpKSAvIHNjYWxlRmFjdG9yIC8gMjtcbiAgICB2YXIgaW5wdXRQYWRkaW5nID0gdmFsLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobiB8fCAnMCcpIC8gcHhTY2FsZUZhY3RvcjtcbiAgICB9KTtcbiAgICB2YXIgcGFkZGluZyA9ICgwLCBjb21tb25fMS5wYXJzZVNwYWNpbmcpKGlucHV0UGFkZGluZywgMCk7XG4gICAgaWYgKGxpbmVQYWRkaW5nID4gcGFkZGluZy50b3ApIHtcbiAgICAgICAgcGFkZGluZy50b3AgPSBsaW5lUGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxpbmVQYWRkaW5nID4gcGFkZGluZy5ib3R0b20pIHtcbiAgICAgICAgcGFkZGluZy5ib3R0b20gPSBsaW5lUGFkZGluZztcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRpbmc7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc0NDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Eb2NIYW5kbGVyID0gdm9pZCAwO1xudmFyIGdsb2JhbERlZmF1bHRzID0ge307XG52YXIgRG9jSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2NIYW5kbGVyKGpzUERGRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5qc1BERkRvY3VtZW50ID0ganNQREZEb2N1bWVudDtcbiAgICAgICAgdGhpcy51c2VyU3R5bGVzID0ge1xuICAgICAgICAgICAgLy8gQmxhY2sgZm9yIHZlcnNpb25zIG9mIGpzcGRmIHdpdGhvdXQgZ2V0VGV4dENvbG9yXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IGpzUERGRG9jdW1lbnQuZ2V0VGV4dENvbG9yXG4gICAgICAgICAgICAgICAgPyB0aGlzLmpzUERGRG9jdW1lbnQuZ2V0VGV4dENvbG9yKClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBmb250U2l6ZToganNQREZEb2N1bWVudC5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBqc1BERkRvY3VtZW50LmludGVybmFsLmdldEZvbnQoKS5mb250U3R5bGUsXG4gICAgICAgICAgICBmb250OiBqc1BERkRvY3VtZW50LmludGVybmFsLmdldEZvbnQoKS5mb250TmFtZSxcbiAgICAgICAgICAgIC8vIDAgZm9yIHZlcnNpb25zIG9mIGpzcGRmIHdpdGhvdXQgZ2V0TGluZVdpZHRoXG4gICAgICAgICAgICBsaW5lV2lkdGg6IGpzUERGRG9jdW1lbnQuZ2V0TGluZVdpZHRoXG4gICAgICAgICAgICAgICAgPyB0aGlzLmpzUERGRG9jdW1lbnQuZ2V0TGluZVdpZHRoKClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAvLyBCbGFjayBmb3IgdmVyc2lvbnMgb2YganNwZGYgd2l0aG91dCBnZXREcmF3Q29sb3JcbiAgICAgICAgICAgIGxpbmVDb2xvcjoganNQREZEb2N1bWVudC5nZXREcmF3Q29sb3JcbiAgICAgICAgICAgICAgICA/IHRoaXMuanNQREZEb2N1bWVudC5nZXREcmF3Q29sb3IoKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRG9jSGFuZGxlci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgZG9jKSB7XG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBudWxsOyB9XG4gICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgIGRvYy5fX2F1dG9UYWJsZURvY3VtZW50RGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbERlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY0hhbmRsZXIudW5pZnlDb2xvciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgYywgY107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLmFwcGx5U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcywgZm9udE9ubHkpIHtcbiAgICAgICAgLy8gRm9udCBzdHlsZSBuZWVkcyB0byBiZSBhcHBsaWVkIGJlZm9yZSBmb250XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1vbmJlbmd0c3Nvbi9qc1BERi1BdXRvVGFibGUvaXNzdWVzLzYzMlxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGZvbnRPbmx5ID09PSB2b2lkIDApIHsgZm9udE9ubHkgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoc3R5bGVzLmZvbnRTdHlsZSlcbiAgICAgICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRGb250U3R5bGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmpzUERGRG9jdW1lbnQuc2V0Rm9udFN0eWxlKHN0eWxlcy5mb250U3R5bGUpO1xuICAgICAgICB2YXIgX2QgPSB0aGlzLmpzUERGRG9jdW1lbnQuaW50ZXJuYWwuZ2V0Rm9udCgpLCBmb250U3R5bGUgPSBfZC5mb250U3R5bGUsIGZvbnROYW1lID0gX2QuZm9udE5hbWU7XG4gICAgICAgIGlmIChzdHlsZXMuZm9udClcbiAgICAgICAgICAgIGZvbnROYW1lID0gc3R5bGVzLmZvbnQ7XG4gICAgICAgIGlmIChzdHlsZXMuZm9udFN0eWxlKSB7XG4gICAgICAgICAgICBmb250U3R5bGUgPSBzdHlsZXMuZm9udFN0eWxlO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUZvbnRTdHlsZXMgPSB0aGlzLmdldEZvbnRMaXN0KClbZm9udE5hbWVdO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZUZvbnRTdHlsZXMgJiZcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVGb250U3R5bGVzLmluZGV4T2YoZm9udFN0eWxlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tb24gaXNzdWUgd2FzIHRoYXQgdGhlIGRlZmF1bHQgYm9sZCBpbiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgLy8gbWFkZSBjdXN0b20gZm9udHMgbm90IHdvcmsuIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1vbmJlbmd0c3Nvbi9qc1BERi1BdXRvVGFibGUvaXNzdWVzLzY1M1xuICAgICAgICAgICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRGb250U3R5bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qc1BERkRvY3VtZW50LnNldEZvbnRTdHlsZShhdmFpbGFibGVGb250U3R5bGVzWzBdKTtcbiAgICAgICAgICAgICAgICBmb250U3R5bGUgPSBhdmFpbGFibGVGb250U3R5bGVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRGb250KGZvbnROYW1lLCBmb250U3R5bGUpO1xuICAgICAgICBpZiAoc3R5bGVzLmZvbnRTaXplKVxuICAgICAgICAgICAgdGhpcy5qc1BERkRvY3VtZW50LnNldEZvbnRTaXplKHN0eWxlcy5mb250U2l6ZSk7XG4gICAgICAgIGlmIChmb250T25seSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBQZXJmb3JtYW5jZSBpbXByb3ZlbWVudFxuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvciA9IERvY0hhbmRsZXIudW5pZnlDb2xvcihzdHlsZXMuZmlsbENvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yKVxuICAgICAgICAgICAgKF9hID0gdGhpcy5qc1BERkRvY3VtZW50KS5zZXRGaWxsQ29sb3IuYXBwbHkoX2EsIGNvbG9yKTtcbiAgICAgICAgY29sb3IgPSBEb2NIYW5kbGVyLnVuaWZ5Q29sb3Ioc3R5bGVzLnRleHRDb2xvcik7XG4gICAgICAgIGlmIChjb2xvcilcbiAgICAgICAgICAgIChfYiA9IHRoaXMuanNQREZEb2N1bWVudCkuc2V0VGV4dENvbG9yLmFwcGx5KF9iLCBjb2xvcik7XG4gICAgICAgIGNvbG9yID0gRG9jSGFuZGxlci51bmlmeUNvbG9yKHN0eWxlcy5saW5lQ29sb3IpO1xuICAgICAgICBpZiAoY29sb3IpXG4gICAgICAgICAgICAoX2MgPSB0aGlzLmpzUERGRG9jdW1lbnQpLnNldERyYXdDb2xvci5hcHBseShfYywgY29sb3IpO1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlcy5saW5lV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmpzUERGRG9jdW1lbnQuc2V0TGluZVdpZHRoKHN0eWxlcy5saW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5zcGxpdFRleHRUb1NpemUgPSBmdW5jdGlvbiAodGV4dCwgc2l6ZSwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50LnNwbGl0VGV4dFRvU2l6ZSh0ZXh0LCBzaXplLCBvcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZWN0YW5nbGUgdG8gdGhlIFBERlxuICAgICAqIEBwYXJhbSB4IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgbGVmdCBlZGdlIG9mIHRoZSBwYWdlXG4gICAgICogQHBhcmFtIHkgQ29vcmRpbmF0ZSAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudCkgYWdhaW5zdCB1cHBlciBlZGdlIG9mIHRoZSBwYWdlXG4gICAgICogQHBhcmFtIHdpZHRoIFdpZHRoIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KVxuICAgICAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KVxuICAgICAqIEBwYXJhbSBmaWxsU3R5bGUgQSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgcGFpbnRpbmcgc3R5bGUgb3IgbnVsbC4gVmFsaWQgc3R5bGVzIGluY2x1ZGU6ICdTJyBbZGVmYXVsdF0gLSBzdHJva2UsICdGJyAtIGZpbGwsIGFuZCAnREYnIChvciAnRkQnKSAtIGZpbGwgdGhlbiBzdHJva2UuXG4gICAgICovXG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsU3R5bGUpIHtcbiAgICAgICAgLy8gbnVsbCBpcyBleGNsdWRlZCBmcm9tIGZpbGxTdHlsZSBwb3NzaWJsZSB2YWx1ZXMgYmVjYXVzZSBpdCBpc24ndCBuZWVkZWRcbiAgICAgICAgLy8gYW5kIGlzIHByb25lIHRvIGJ1Z3MgYXMgaXQncyB1c2VkIHRvIHBvc3Rwb25lIHNldHRpbmcgdGhlIHN0eWxlXG4gICAgICAgIC8vIGh0dHBzOi8vcmF3Z2l0LmNvbS9NclJpby9qc1BERi9tYXN0ZXIvZG9jcy9qc1BERi5odG1sI3JlY3RcbiAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxTdHlsZSk7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5nZXRMYXN0QXV0b1RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50Lmxhc3RBdXRvVGFibGUgfHwgbnVsbDtcbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLmdldFRleHRXaWR0aCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzUERGRG9jdW1lbnQuZ2V0VGV4dFdpZHRoKHRleHQpO1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzUERGRG9jdW1lbnQ7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5zZXRQYWdlID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgICAgdGhpcy5qc1BERkRvY3VtZW50LnNldFBhZ2UocGFnZSk7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5hZGRQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50LmFkZFBhZ2UoKTtcbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLmdldEZvbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50LmdldEZvbnRMaXN0KCk7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5nZXRHbG9iYWxPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRGVmYXVsdHMgfHwge307XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5nZXREb2N1bWVudE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzUERGRG9jdW1lbnQuX19hdXRvVGFibGVEb2N1bWVudERlZmF1bHRzIHx8IHt9O1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUucGFnZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYWdlU2l6ZSA9IHRoaXMuanNQREZEb2N1bWVudC5pbnRlcm5hbC5wYWdlU2l6ZTtcbiAgICAgICAgLy8gSlNQREYgMS40IHVzZXMgZ2V0IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHByb3BlcnRpZXMgb24gcGFnZVNpemVcbiAgICAgICAgaWYgKHBhZ2VTaXplLndpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhZ2VTaXplID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwYWdlU2l6ZS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFnZVNpemUuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWdlU2l6ZTtcbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLnNjYWxlRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50LmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuZ2V0TGluZUhlaWdodEZhY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuanNQREZEb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvYy5nZXRMaW5lSGVpZ2h0RmFjdG9yID8gZG9jLmdldExpbmVIZWlnaHRGYWN0b3IoKSA6IDEuMTU7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5nZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKGZvbnRTaXplKSB7XG4gICAgICAgIHJldHVybiAoZm9udFNpemUgLyB0aGlzLnNjYWxlRmFjdG9yKCkpICogdGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCk7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5wYWdlTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFnZUluZm8gPSB0aGlzLmpzUERGRG9jdW1lbnQuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCk7XG4gICAgICAgIGlmICghcGFnZUluZm8pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmVjZW50IHZlcnNpb25zIG9mIGpzcGRmIGhhcyBwYWdlSW5mb1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZ2VJbmZvLnBhZ2VOdW1iZXI7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkRvY0hhbmRsZXIgPSBEb2NIYW5kbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLnBhcnNlSHRtbCA9IHZvaWQgMDtcbnZhciBjc3NQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzKTtcbnZhciBjb25maWdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzk2KTtcbmZ1bmN0aW9uIHBhcnNlSHRtbChkb2MsIGlucHV0LCB3aW5kb3csIGluY2x1ZGVIaWRkZW5IdG1sLCB1c2VDc3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChpbmNsdWRlSGlkZGVuSHRtbCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIaWRkZW5IdG1sID0gZmFsc2U7IH1cbiAgICBpZiAodXNlQ3NzID09PSB2b2lkIDApIHsgdXNlQ3NzID0gZmFsc2U7IH1cbiAgICB2YXIgdGFibGVFbGVtZW50O1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRhYmxlRWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGlucHV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhYmxlRWxlbWVudCA9IGlucHV0O1xuICAgIH1cbiAgICB2YXIgc3VwcG9ydGVkRm9udHMgPSBPYmplY3Qua2V5cyhkb2MuZ2V0Rm9udExpc3QoKSk7XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gZG9jLnNjYWxlRmFjdG9yKCk7XG4gICAgdmFyIGhlYWQgPSBbXSwgYm9keSA9IFtdLCBmb290ID0gW107XG4gICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSHRtbCB0YWJsZSBjb3VsZCBub3QgYmUgZm91bmQgd2l0aCBpbnB1dDogJywgaW5wdXQpO1xuICAgICAgICByZXR1cm4geyBoZWFkOiBoZWFkLCBib2R5OiBib2R5LCBmb290OiBmb290IH07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGVFbGVtZW50LnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0YWJsZUVsZW1lbnQucm93c1tpXTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSAoX2IgPSAoX2EgPSBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhZ05hbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgcm93ID0gcGFyc2VSb3dDb250ZW50KHN1cHBvcnRlZEZvbnRzLCBzY2FsZUZhY3Rvciwgd2luZG93LCBlbGVtZW50LCBpbmNsdWRlSGlkZGVuSHRtbCwgdXNlQ3NzKTtcbiAgICAgICAgaWYgKCFyb3cpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICd0aGVhZCcpIHtcbiAgICAgICAgICAgIGhlYWQucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09ICd0Zm9vdCcpIHtcbiAgICAgICAgICAgIGZvb3QucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIHRvIGJvZHkgYm90aCBpZiBwYXJlbnQgaXMgdGJvZHkgb3IgdGFibGVcbiAgICAgICAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGhlYWQ6IGhlYWQsIGJvZHk6IGJvZHksIGZvb3Q6IGZvb3QgfTtcbn1cbmV4cG9ydHMucGFyc2VIdG1sID0gcGFyc2VIdG1sO1xuZnVuY3Rpb24gcGFyc2VSb3dDb250ZW50KHN1cHBvcnRlZEZvbnRzLCBzY2FsZUZhY3Rvciwgd2luZG93LCByb3csIGluY2x1ZGVIaWRkZW4sIHVzZUNzcykge1xuICAgIHZhciByZXN1bHRSb3cgPSBuZXcgY29uZmlnXzEuSHRtbFJvd0lucHV0KHJvdyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cuY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbaV07XG4gICAgICAgIHZhciBzdHlsZV8xID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCk7XG4gICAgICAgIGlmIChpbmNsdWRlSGlkZGVuIHx8IHN0eWxlXzEuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB2YXIgY2VsbFN0eWxlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VDc3MpIHtcbiAgICAgICAgICAgICAgICBjZWxsU3R5bGVzID0gKDAsIGNzc1BhcnNlcl8xLnBhcnNlQ3NzKShzdXBwb3J0ZWRGb250cywgY2VsbCwgc2NhbGVGYWN0b3IsIHN0eWxlXzEsIHdpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRSb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgcm93U3BhbjogY2VsbC5yb3dTcGFuLFxuICAgICAgICAgICAgICAgIGNvbFNwYW46IGNlbGwuY29sU3BhbixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IGNlbGxTdHlsZXMsXG4gICAgICAgICAgICAgICAgX2VsZW1lbnQ6IGNlbGwsXG4gICAgICAgICAgICAgICAgY29udGVudDogcGFyc2VDZWxsQ29udGVudChjZWxsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJvdyk7XG4gICAgaWYgKHJlc3VsdFJvdy5sZW5ndGggPiAwICYmIChpbmNsdWRlSGlkZGVuIHx8IHN0eWxlLmRpc3BsYXkgIT09ICdub25lJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFJvdztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUNlbGxDb250ZW50KG9yZ0NlbGwpIHtcbiAgICAvLyBXb3JrIG9uIGNsb25lZCBub2RlIHRvIG1ha2Ugc3VyZSBubyBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIGh0bWwgdGFibGVcbiAgICB2YXIgY2VsbCA9IG9yZ0NlbGwuY2xvbmVOb2RlKHRydWUpO1xuICAgIC8vIFJlbW92ZSBleHRyYSBzcGFjZSBhbmQgbGluZSBicmVha3MgaW4gbWFya3VwIHRvIG1ha2UgaXQgbW9yZSBzaW1pbGFyIHRvXG4gICAgLy8gd2hhdCB3b3VsZCBiZSBzaG93biBpbiBodG1sXG4gICAgY2VsbC5pbm5lckhUTUwgPSBjZWxsLmlubmVySFRNTC5yZXBsYWNlKC9cXG4vZywgJycpLnJlcGxhY2UoLyArL2csICcgJyk7XG4gICAgLy8gUHJlc2VydmUgPGJyPiB0YWdzIGFzIGxpbmUgYnJlYWtzIGluIHRoZSBwZGZcbiAgICBjZWxsLmlubmVySFRNTCA9IGNlbGwuaW5uZXJIVE1MXG4gICAgICAgIC5zcGxpdCgvPGJyLio/Pi8pIC8vc3RhcnQgd2l0aCAnPGJyJyBhbmQgZW5kcyB3aXRoICc+Jy5cbiAgICAgICAgLm1hcChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydC50cmltKCk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAvLyBpbm5lclRleHQgZm9yIGllXG4gICAgcmV0dXJuIGNlbGwuaW5uZXJUZXh0IHx8IGNlbGwudGV4dENvbnRlbnQgfHwgJyc7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc3Njpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5wYXJzZUlucHV0ID0gdm9pZCAwO1xudmFyIGh0bWxQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgcG9seWZpbGxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1Nik7XG52YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMCk7XG52YXIgZG9jdW1lbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NCk7XG52YXIgaW5wdXRWYWxpZGF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkyKTtcbmZ1bmN0aW9uIHBhcnNlSW5wdXQoZCwgY3VycmVudCkge1xuICAgIHZhciBkb2MgPSBuZXcgZG9jdW1lbnRIYW5kbGVyXzEuRG9jSGFuZGxlcihkKTtcbiAgICB2YXIgZG9jdW1lbnQgPSBkb2MuZ2V0RG9jdW1lbnRPcHRpb25zKCk7XG4gICAgdmFyIGdsb2JhbCA9IGRvYy5nZXRHbG9iYWxPcHRpb25zKCk7XG4gICAgKDAsIGlucHV0VmFsaWRhdG9yXzEuZGVmYXVsdCkoZG9jLCBnbG9iYWwsIGRvY3VtZW50LCBjdXJyZW50KTtcbiAgICB2YXIgb3B0aW9ucyA9ICgwLCBwb2x5ZmlsbHNfMS5hc3NpZ24pKHt9LCBnbG9iYWwsIGRvY3VtZW50LCBjdXJyZW50KTtcbiAgICB2YXIgd2luO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgfVxuICAgIHZhciBzdHlsZXMgPSBwYXJzZVN0eWxlcyhnbG9iYWwsIGRvY3VtZW50LCBjdXJyZW50KTtcbiAgICB2YXIgaG9va3MgPSBwYXJzZUhvb2tzKGdsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnQpO1xuICAgIHZhciBzZXR0aW5ncyA9IHBhcnNlU2V0dGluZ3MoZG9jLCBvcHRpb25zKTtcbiAgICB2YXIgY29udGVudCA9IHBhcnNlQ29udGVudChkb2MsIG9wdGlvbnMsIHdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGN1cnJlbnQudGFibGVJZCxcbiAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgaG9va3M6IGhvb2tzLFxuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlSW5wdXQgPSBwYXJzZUlucHV0O1xuZnVuY3Rpb24gcGFyc2VTdHlsZXMoZ0lucHV0LCBkSW5wdXQsIGNJbnB1dCkge1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSB7XG4gICAgICAgIHN0eWxlczoge30sXG4gICAgICAgIGhlYWRTdHlsZXM6IHt9LFxuICAgICAgICBib2R5U3R5bGVzOiB7fSxcbiAgICAgICAgZm9vdFN0eWxlczoge30sXG4gICAgICAgIGFsdGVybmF0ZVJvd1N0eWxlczoge30sXG4gICAgICAgIGNvbHVtblN0eWxlczoge30sXG4gICAgfTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnY29sdW1uU3R5bGVzJykge1xuICAgICAgICAgICAgdmFyIGdsb2JhbF8xID0gZ0lucHV0W3Byb3BdO1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50XzEgPSBkSW5wdXRbcHJvcF07XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGNJbnB1dFtwcm9wXTtcbiAgICAgICAgICAgIHN0eWxlT3B0aW9ucy5jb2x1bW5TdHlsZXMgPSAoMCwgcG9seWZpbGxzXzEuYXNzaWduKSh7fSwgZ2xvYmFsXzEsIGRvY3VtZW50XzEsIGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFsbE9wdGlvbnMgPSBbZ0lucHV0LCBkSW5wdXQsIGNJbnB1dF07XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gYWxsT3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdHMpIHsgcmV0dXJuIG9wdHNbcHJvcF0gfHwge307IH0pO1xuICAgICAgICAgICAgc3R5bGVPcHRpb25zW3Byb3BdID0gKDAsIHBvbHlmaWxsc18xLmFzc2lnbikoe30sIHN0eWxlc1swXSwgc3R5bGVzWzFdLCBzdHlsZXNbMl0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoc3R5bGVPcHRpb25zKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBfYVtfaV07XG4gICAgICAgIF9sb29wXzEocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZU9wdGlvbnM7XG59XG5mdW5jdGlvbiBwYXJzZUhvb2tzKGdsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnQpIHtcbiAgICB2YXIgYWxsT3B0aW9ucyA9IFtnbG9iYWwsIGRvY3VtZW50LCBjdXJyZW50XTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBkaWRQYXJzZUNlbGw6IFtdLFxuICAgICAgICB3aWxsRHJhd0NlbGw6IFtdLFxuICAgICAgICBkaWREcmF3Q2VsbDogW10sXG4gICAgICAgIHdpbGxEcmF3UGFnZTogW10sXG4gICAgICAgIGRpZERyYXdQYWdlOiBbXSxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgYWxsT3B0aW9uc18xID0gYWxsT3B0aW9uczsgX2kgPCBhbGxPcHRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYWxsT3B0aW9uc18xW19pXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlkUGFyc2VDZWxsKVxuICAgICAgICAgICAgcmVzdWx0LmRpZFBhcnNlQ2VsbC5wdXNoKG9wdGlvbnMuZGlkUGFyc2VDZWxsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lsbERyYXdDZWxsKVxuICAgICAgICAgICAgcmVzdWx0LndpbGxEcmF3Q2VsbC5wdXNoKG9wdGlvbnMud2lsbERyYXdDZWxsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlkRHJhd0NlbGwpXG4gICAgICAgICAgICByZXN1bHQuZGlkRHJhd0NlbGwucHVzaChvcHRpb25zLmRpZERyYXdDZWxsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lsbERyYXdQYWdlKVxuICAgICAgICAgICAgcmVzdWx0LndpbGxEcmF3UGFnZS5wdXNoKG9wdGlvbnMud2lsbERyYXdQYWdlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlkRHJhd1BhZ2UpXG4gICAgICAgICAgICByZXN1bHQuZGlkRHJhd1BhZ2UucHVzaChvcHRpb25zLmRpZERyYXdQYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2V0dGluZ3MoZG9jLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgdmFyIG1hcmdpbiA9ICgwLCBjb21tb25fMS5wYXJzZVNwYWNpbmcpKG9wdGlvbnMubWFyZ2luLCA0MCAvIGRvYy5zY2FsZUZhY3RvcigpKTtcbiAgICB2YXIgc3RhcnRZID0gKF9hID0gZ2V0U3RhcnRZKGRvYywgb3B0aW9ucy5zdGFydFkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtYXJnaW4udG9wO1xuICAgIHZhciBzaG93Rm9vdDtcbiAgICBpZiAob3B0aW9ucy5zaG93Rm9vdCA9PT0gdHJ1ZSkge1xuICAgICAgICBzaG93Rm9vdCA9ICdldmVyeVBhZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnNob3dGb290ID09PSBmYWxzZSkge1xuICAgICAgICBzaG93Rm9vdCA9ICduZXZlcic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaG93Rm9vdCA9IChfYiA9IG9wdGlvbnMuc2hvd0Zvb3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdldmVyeVBhZ2UnO1xuICAgIH1cbiAgICB2YXIgc2hvd0hlYWQ7XG4gICAgaWYgKG9wdGlvbnMuc2hvd0hlYWQgPT09IHRydWUpIHtcbiAgICAgICAgc2hvd0hlYWQgPSAnZXZlcnlQYWdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5zaG93SGVhZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2hvd0hlYWQgPSAnbmV2ZXInO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2hvd0hlYWQgPSAoX2MgPSBvcHRpb25zLnNob3dIZWFkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnZXZlcnlQYWdlJztcbiAgICB9XG4gICAgdmFyIHVzZUNzcyA9IChfZCA9IG9wdGlvbnMudXNlQ3NzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICB2YXIgdGhlbWUgPSBvcHRpb25zLnRoZW1lIHx8ICh1c2VDc3MgPyAncGxhaW4nIDogJ3N0cmlwZWQnKTtcbiAgICB2YXIgaG9yaXpvbnRhbFBhZ2VCcmVhayA9ICEhb3B0aW9ucy5ob3Jpem9udGFsUGFnZUJyZWFrO1xuICAgIHZhciBob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID0gKF9lID0gb3B0aW9ucy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGluY2x1ZGVIaWRkZW5IdG1sOiAoX2YgPSBvcHRpb25zLmluY2x1ZGVIaWRkZW5IdG1sKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZSxcbiAgICAgICAgdXNlQ3NzOiB1c2VDc3MsXG4gICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgICBwYWdlQnJlYWs6IChfZyA9IG9wdGlvbnMucGFnZUJyZWFrKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAnYXV0bycsXG4gICAgICAgIHJvd1BhZ2VCcmVhazogKF9oID0gb3B0aW9ucy5yb3dQYWdlQnJlYWspICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICdhdXRvJyxcbiAgICAgICAgdGFibGVXaWR0aDogKF9qID0gb3B0aW9ucy50YWJsZVdpZHRoKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAnYXV0bycsXG4gICAgICAgIHNob3dIZWFkOiBzaG93SGVhZCxcbiAgICAgICAgc2hvd0Zvb3Q6IHNob3dGb290LFxuICAgICAgICB0YWJsZUxpbmVXaWR0aDogKF9rID0gb3B0aW9ucy50YWJsZUxpbmVXaWR0aCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogMCxcbiAgICAgICAgdGFibGVMaW5lQ29sb3I6IChfbCA9IG9wdGlvbnMudGFibGVMaW5lQ29sb3IpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IDIwMCxcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVhazogaG9yaXpvbnRhbFBhZ2VCcmVhayxcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdDogaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCxcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVha0JlaGF2aW91cjogKF9tID0gb3B0aW9ucy5ob3Jpem9udGFsUGFnZUJyZWFrQmVoYXZpb3VyKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiAnYWZ0ZXJBbGxSb3dzJyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRZKGRvYywgdXNlclN0YXJ0WSkge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5nZXRMYXN0QXV0b1RhYmxlKCk7XG4gICAgdmFyIHNmID0gZG9jLnNjYWxlRmFjdG9yKCk7XG4gICAgdmFyIGN1cnJlbnRQYWdlID0gZG9jLnBhZ2VOdW1iZXIoKTtcbiAgICB2YXIgaXNTYW1lUGFnZUFzUHJldmlvdXNUYWJsZSA9IGZhbHNlO1xuICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5zdGFydFBhZ2VOdW1iZXIpIHtcbiAgICAgICAgdmFyIGVuZGluZ1BhZ2UgPSBwcmV2aW91cy5zdGFydFBhZ2VOdW1iZXIgKyBwcmV2aW91cy5wYWdlTnVtYmVyIC0gMTtcbiAgICAgICAgaXNTYW1lUGFnZUFzUHJldmlvdXNUYWJsZSA9IGVuZGluZ1BhZ2UgPT09IGN1cnJlbnRQYWdlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVzZXJTdGFydFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB1c2VyU3RhcnRZO1xuICAgIH1cbiAgICBlbHNlIGlmICh1c2VyU3RhcnRZID09IG51bGwgfHwgdXNlclN0YXJ0WSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzU2FtZVBhZ2VBc1ByZXZpb3VzVGFibGUgJiYgKHByZXZpb3VzID09PSBudWxsIHx8IHByZXZpb3VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91cy5maW5hbFkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgdXNlcnMgaGFkIGlzc3VlcyB3aXRoIG92ZXJsYXBwaW5nIHRhYmxlcyB3aGVuIHRoZXkgdXNlZCBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gdGFibGVzIHdpdGhvdXQgc2V0dGluZyBzdGFydFkgc28gc2V0dGluZyBpdCBoZXJlIHRvIGEgc2Vuc2libGUgZGVmYXVsdC5cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cy5maW5hbFkgKyAyMCAvIHNmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VDb250ZW50KGRvYywgb3B0aW9ucywgd2luZG93KSB7XG4gICAgdmFyIGhlYWQgPSBvcHRpb25zLmhlYWQgfHwgW107XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgW107XG4gICAgdmFyIGZvb3QgPSBvcHRpb25zLmZvb3QgfHwgW107XG4gICAgaWYgKG9wdGlvbnMuaHRtbCkge1xuICAgICAgICB2YXIgaGlkZGVuID0gb3B0aW9ucy5pbmNsdWRlSGlkZGVuSHRtbDtcbiAgICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICAgICAgdmFyIGh0bWxDb250ZW50ID0gKDAsIGh0bWxQYXJzZXJfMS5wYXJzZUh0bWwpKGRvYywgb3B0aW9ucy5odG1sLCB3aW5kb3csIGhpZGRlbiwgb3B0aW9ucy51c2VDc3MpIHx8IHt9O1xuICAgICAgICAgICAgaGVhZCA9IGh0bWxDb250ZW50LmhlYWQgfHwgaGVhZDtcbiAgICAgICAgICAgIGJvZHkgPSBodG1sQ29udGVudC5ib2R5IHx8IGhlYWQ7XG4gICAgICAgICAgICBmb290ID0gaHRtbENvbnRlbnQuZm9vdCB8fCBoZWFkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHBhcnNlIGh0bWwgaW4gbm9uIGJyb3dzZXIgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucyB8fCBwYXJzZUNvbHVtbnMoaGVhZCwgYm9keSwgZm9vdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgaGVhZDogaGVhZCxcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgZm9vdDogZm9vdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VDb2x1bW5zKGhlYWQsIGJvZHksIGZvb3QpIHtcbiAgICB2YXIgZmlyc3RSb3cgPSBoZWFkWzBdIHx8IGJvZHlbMF0gfHwgZm9vdFswXSB8fCBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgT2JqZWN0LmtleXMoZmlyc3RSb3cpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ICE9PSAnX2VsZW1lbnQnOyB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBjb2xTcGFuID0gMTtcbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdFJvdykpIHtcbiAgICAgICAgICAgIGlucHV0ID0gZmlyc3RSb3dbcGFyc2VJbnQoa2V5KV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dCA9IGZpcnN0Um93W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb2xTcGFuID0gKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC5jb2xTcGFuKSB8fCAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sU3BhbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdFJvdykpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IGtleSArIChpID4gMCA/IFwiX1wiLmNvbmNhdChpKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb3dSZXN1bHQgPSB7IGRhdGFLZXk6IGlkIH07XG4gICAgICAgICAgICByZXN1bHQucHVzaChyb3dSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzkyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5mdW5jdGlvbiBkZWZhdWx0XzEoZG9jLCBnbG9iYWwsIGRvY3VtZW50LCBjdXJyZW50KSB7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBvcHRpb25zIHBhcmFtZXRlciBzaG91bGQgYmUgb2YgdHlwZSBvYmplY3QsIGlzOiAnICsgdHlwZW9mIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHRlbmRXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGFibGVXaWR0aCA9IG9wdGlvbnMuZXh0ZW5kV2lkdGggPyAnYXV0bycgOiAnd3JhcCc7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVc2Ugb2YgZGVwcmVjYXRlZCBvcHRpb246IGV4dGVuZFdpZHRoLCB1c2UgdGFibGVXaWR0aCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXJnaW4gPSBvcHRpb25zLm1hcmdpbnM7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVc2Ugb2YgZGVwcmVjYXRlZCBvcHRpb246IG1hcmdpbnMsIHVzZSBtYXJnaW4gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydFkgJiYgdHlwZW9mIG9wdGlvbnMuc3RhcnRZICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igc3RhcnRZIG9wdGlvbicsIG9wdGlvbnMuc3RhcnRZKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnN0YXJ0WTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuZGlkRHJhd1BhZ2UgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmFmdGVyUGFnZUNvbnRlbnQgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJlZm9yZVBhZ2VDb250ZW50IHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hZnRlclBhZ2VBZGQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgYWZ0ZXJQYWdlQ29udGVudCwgYmVmb3JlUGFnZUNvbnRlbnQgYW5kIGFmdGVyUGFnZUFkZCBob29rcyBhcmUgZGVwcmVjYXRlZC4gVXNlIGRpZERyYXdQYWdlIGluc3RlYWQnKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGlkRHJhd1BhZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlUGFnZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlUGFnZUNvbnRlbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclBhZ2VDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFmdGVyUGFnZUNvbnRlbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclBhZ2VBZGQgJiYgZGF0YS5wYWdlTnVtYmVyID4gMSkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYWZ0ZXJQYWdlQWRkKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIFtcbiAgICAgICAgICAgICdjcmVhdGVkSGVhZGVyQ2VsbCcsXG4gICAgICAgICAgICAnZHJhd0hlYWRlclJvdycsXG4gICAgICAgICAgICAnZHJhd1JvdycsXG4gICAgICAgICAgICAnZHJhd0hlYWRlckNlbGwnLFxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBob29rIGhhcyBjaGFuZ2VkIGluIHZlcnNpb24gMy4wLCBjaGVjayB0aGUgY2hhbmdlbG9nIGZvciBob3cgdG8gbWlncmF0ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgW1xuICAgICAgICAgICAgWydzaG93Rm9vdCcsICdzaG93Rm9vdGVyJ10sXG4gICAgICAgICAgICBbJ3Nob3dIZWFkJywgJ3Nob3dIZWFkZXInXSxcbiAgICAgICAgICAgIFsnZGlkRHJhd1BhZ2UnLCAnYWRkUGFnZUNvbnRlbnQnXSxcbiAgICAgICAgICAgIFsnZGlkUGFyc2VDZWxsJywgJ2NyZWF0ZWRDZWxsJ10sXG4gICAgICAgICAgICBbJ2hlYWRTdHlsZXMnLCAnaGVhZGVyU3R5bGVzJ10sXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gX2FbMF0sIGRlcHJlY2F0ZWQgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW2RlcHJlY2F0ZWRdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVzZSBvZiBkZXByZWNhdGVkIG9wdGlvbiBcIi5jb25jYXQoZGVwcmVjYXRlZCwgXCIuIFVzZSBcIikuY29uY2F0KGN1cnJlbnQsIFwiIGluc3RlYWRcIikpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbY3VycmVudF0gPSBvcHRpb25zW2RlcHJlY2F0ZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgW1xuICAgICAgICAgICAgWydwYWRkaW5nJywgJ2NlbGxQYWRkaW5nJ10sXG4gICAgICAgICAgICBbJ2xpbmVIZWlnaHQnLCAncm93SGVpZ2h0J10sXG4gICAgICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAgICAgJ292ZXJmbG93JyxcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgZGVwcmVjYXRlZE9wdGlvbiA9IHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvWzBdO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG9bMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbZGVwcmVjYXRlZE9wdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0eWxlc1tzdHlsZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVzW3N0eWxlXSA9IG9wdGlvbnNbZGVwcmVjYXRlZE9wdGlvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZSBvZiBkZXByZWNhdGVkIG9wdGlvbjogJyArXG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWRPcHRpb24gK1xuICAgICAgICAgICAgICAgICAgICAnLCB1c2UgdGhlIHN0eWxlICcgK1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSArXG4gICAgICAgICAgICAgICAgICAgICcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBbXG4gICAgICAgICAgICAnc3R5bGVzJyxcbiAgICAgICAgICAgICdib2R5U3R5bGVzJyxcbiAgICAgICAgICAgICdoZWFkU3R5bGVzJyxcbiAgICAgICAgICAgICdmb290U3R5bGVzJyxcbiAgICAgICAgXTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZVByb3AgPSBfY1tfYl07XG4gICAgICAgICAgICBjaGVja1N0eWxlcyhvcHRpb25zW3N0eWxlUHJvcF0gfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2x1bW5TdHlsZXMgPSBvcHRpb25zWydjb2x1bW5TdHlsZXMnXSB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IE9iamVjdC5rZXlzKGNvbHVtblN0eWxlcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2VbX2RdO1xuICAgICAgICAgICAgY2hlY2tTdHlsZXMoY29sdW1uU3R5bGVzW2tleV0gfHwge30pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gW2dsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hW19pXTtcbiAgICAgICAgX2xvb3BfMShvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZmF1bHRfMTtcbmZ1bmN0aW9uIGNoZWNrU3R5bGVzKHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMucm93SGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZSBvZiBkZXByZWNhdGVkIHN0eWxlIHJvd0hlaWdodC4gSXQgaXMgcmVuYW1lZCB0byBtaW5DZWxsSGVpZ2h0LicpO1xuICAgICAgICBpZiAoIXN0eWxlcy5taW5DZWxsSGVpZ2h0KSB7XG4gICAgICAgICAgICBzdHlsZXMubWluQ2VsbEhlaWdodCA9IHN0eWxlcy5yb3dIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3R5bGVzLmNvbHVtbldpZHRoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZSBvZiBkZXByZWNhdGVkIHN0eWxlIGNvbHVtbldpZHRoLiBJdCBpcyByZW5hbWVkIHRvIGNlbGxXaWR0aC4nKTtcbiAgICAgICAgaWYgKCFzdHlsZXMuY2VsbFdpZHRoKSB7XG4gICAgICAgICAgICBzdHlsZXMuY2VsbFdpZHRoID0gc3R5bGVzLmNvbHVtbldpZHRoO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sdW1uID0gZXhwb3J0cy5DZWxsID0gZXhwb3J0cy5Sb3cgPSBleHBvcnRzLlRhYmxlID0gdm9pZCAwO1xudmFyIGNvbmZpZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTYpO1xudmFyIEhvb2tEYXRhXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3Mik7XG52YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMCk7XG52YXIgVGFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFibGUoaW5wdXQsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyID0gMTtcbiAgICAgICAgLy8gRGVwcmVjYXRlZCwgdXNlIHBhZ2VOdW1iZXIgaW5zdGVhZFxuICAgICAgICAvLyBOb3QgdXNpbmcgZ2V0dGVyIHNpbmNlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2ltb25iZW5ndHNzb24vanNQREYtQXV0b1RhYmxlL2lzc3Vlcy81OTZcbiAgICAgICAgdGhpcy5wYWdlQ291bnQgPSAxO1xuICAgICAgICB0aGlzLmlkID0gaW5wdXQuaWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBpbnB1dC5zZXR0aW5ncztcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBpbnB1dC5zdHlsZXM7XG4gICAgICAgIHRoaXMuaG9va3MgPSBpbnB1dC5ob29rcztcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29udGVudC5jb2x1bW5zO1xuICAgICAgICB0aGlzLmhlYWQgPSBjb250ZW50LmhlYWQ7XG4gICAgICAgIHRoaXMuYm9keSA9IGNvbnRlbnQuYm9keTtcbiAgICAgICAgdGhpcy5mb290ID0gY29udGVudC5mb290O1xuICAgIH1cbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0SGVhZEhlaWdodCA9IGZ1bmN0aW9uIChjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJvdykgeyByZXR1cm4gYWNjICsgcm93LmdldE1heENlbGxIZWlnaHQoY29sdW1ucyk7IH0sIDApO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldEZvb3RIZWlnaHQgPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mb290LnJlZHVjZShmdW5jdGlvbiAoYWNjLCByb3cpIHsgcmV0dXJuIGFjYyArIHJvdy5nZXRNYXhDZWxsSGVpZ2h0KGNvbHVtbnMpOyB9LCAwKTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hbGxSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmNvbmNhdCh0aGlzLmJvZHkpLmNvbmNhdCh0aGlzLmZvb3QpO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNhbGxDZWxsSG9va3MgPSBmdW5jdGlvbiAoZG9jLCBoYW5kbGVycywgY2VsbCwgcm93LCBjb2x1bW4sIGN1cnNvcikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2kgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19pXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IEhvb2tEYXRhXzEuQ2VsbEhvb2tEYXRhKGRvYywgdGhpcywgY2VsbCwgcm93LCBjb2x1bW4sIGN1cnNvcik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlcihkYXRhKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGV4dCBpcyBhbHdheXMgc3RyaW5nW10gc2luY2UgdXNlciBjYW4gYXNzaWduIHN0cmluZ1xuICAgICAgICAgICAgY2VsbC50ZXh0ID0gQXJyYXkuaXNBcnJheShjZWxsLnRleHQpID8gY2VsbC50ZXh0IDogW2NlbGwudGV4dF07XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNhbGxFbmRQYWdlSG9va3MgPSBmdW5jdGlvbiAoZG9jLCBjdXJzb3IpIHtcbiAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuaG9va3MuZGlkRHJhd1BhZ2U7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGhhbmRsZXIobmV3IEhvb2tEYXRhXzEuSG9va0RhdGEoZG9jLCB0aGlzLCBjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNhbGxXaWxsRHJhd1BhZ2VIb29rcyA9IGZ1bmN0aW9uIChkb2MsIGN1cnNvcikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5ob29rcy53aWxsRHJhd1BhZ2U7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGhhbmRsZXIobmV3IEhvb2tEYXRhXzEuSG9va0RhdGEoZG9jLCB0aGlzLCBjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKHBhZ2VXaWR0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3MudGFibGVXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnRhYmxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZXR0aW5ncy50YWJsZVdpZHRoID09PSAnd3JhcCcpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkV2lkdGggPSB0aGlzLmNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgY29sKSB7IHJldHVybiB0b3RhbCArIGNvbC53cmFwcGVkV2lkdGg7IH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLnNldHRpbmdzLm1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybiBwYWdlV2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufSgpKTtcbmV4cG9ydHMuVGFibGUgPSBUYWJsZTtcbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm93KHJhdywgaW5kZXgsIHNlY3Rpb24sIGNlbGxzLCBzcGFuc011bHRpcGxlUGFnZXMpIHtcbiAgICAgICAgaWYgKHNwYW5zTXVsdGlwbGVQYWdlcyA9PT0gdm9pZCAwKSB7IHNwYW5zTXVsdGlwbGVQYWdlcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIGlmIChyYXcgaW5zdGFuY2VvZiBjb25maWdfMS5IdG1sUm93SW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMucmF3ID0gcmF3Ll9lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gcmF3Ll9lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zZWN0aW9uID0gc2VjdGlvbjtcbiAgICAgICAgdGhpcy5jZWxscyA9IGNlbGxzO1xuICAgICAgICB0aGlzLnNwYW5zTXVsdGlwbGVQYWdlcyA9IHNwYW5zTXVsdGlwbGVQYWdlcztcbiAgICB9XG4gICAgUm93LnByb3RvdHlwZS5nZXRNYXhDZWxsSGVpZ2h0ID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikgeyB2YXIgX2E7IHJldHVybiBNYXRoLm1heChhY2MsICgoX2EgPSBfdGhpcy5jZWxsc1tjb2x1bW4uaW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKTsgfSwgMCk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmhhc1Jvd1NwYW4gPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX3RoaXMuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5yb3dTcGFuID4gMTtcbiAgICAgICAgfSkubGVuZ3RoID4gMCk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmNhbkVudGlyZVJvd0ZpdCA9IGZ1bmN0aW9uIChoZWlnaHQsIGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4Q2VsbEhlaWdodChjb2x1bW5zKSA8PSBoZWlnaHQ7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmdldE1pbmltdW1Sb3dIZWlnaHQgPSBmdW5jdGlvbiAoY29sdW1ucywgZG9jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX3RoaXMuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZG9jLmdldExpbmVIZWlnaHQoY2VsbC5zdHlsZXMuZm9udFNpemUpO1xuICAgICAgICAgICAgdmFyIHZQYWRkaW5nID0gY2VsbC5wYWRkaW5nKCd2ZXJ0aWNhbCcpO1xuICAgICAgICAgICAgdmFyIG9uZVJvd0hlaWdodCA9IHZQYWRkaW5nICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBvbmVSb3dIZWlnaHQgPiBhY2MgPyBvbmVSb3dIZWlnaHQgOiBhY2M7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgcmV0dXJuIFJvdztcbn0oKSk7XG5leHBvcnRzLlJvdyA9IFJvdztcbnZhciBDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlbGwocmF3LCBzdHlsZXMsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jb250ZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50V2lkdGggPSAwO1xuICAgICAgICB0aGlzLndyYXBwZWRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluUmVhZGFibGVXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5zZWN0aW9uID0gc2VjdGlvbjtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHZhciBjb250ZW50ID0gcmF3O1xuICAgICAgICBpZiAocmF3ICE9IG51bGwgJiYgdHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICAgICAgdGhpcy5yb3dTcGFuID0gcmF3LnJvd1NwYW4gfHwgMTtcbiAgICAgICAgICAgIHRoaXMuY29sU3BhbiA9IHJhdy5jb2xTcGFuIHx8IDE7XG4gICAgICAgICAgICBjb250ZW50ID0gKF9iID0gKF9hID0gcmF3LmNvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJhdy50aXRsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcmF3O1xuICAgICAgICAgICAgaWYgKHJhdy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3ID0gcmF3Ll9lbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3dTcGFuID0gMTtcbiAgICAgICAgICAgIHRoaXMuY29sU3BhbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RyaW5naWZ5IDAgYW5kIGZhbHNlLCBidXQgbm90IHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIHZhciB0ZXh0ID0gY29udGVudCAhPSBudWxsID8gJycgKyBjb250ZW50IDogJyc7XG4gICAgICAgIHZhciBzcGxpdFJlZ2V4ID0gL1xcclxcbnxcXHJ8XFxuL2c7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQuc3BsaXQoc3BsaXRSZWdleCk7XG4gICAgfVxuICAgIENlbGwucHJvdG90eXBlLmdldFRleHRQb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5O1xuICAgICAgICBpZiAodGhpcy5zdHlsZXMudmFsaWduID09PSAndG9wJykge1xuICAgICAgICAgICAgeSA9IHRoaXMueSArIHRoaXMucGFkZGluZygndG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZXMudmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgeSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nKCdib3R0b20nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXRIZWlnaHQgPSB0aGlzLmhlaWdodCAtIHRoaXMucGFkZGluZygndmVydGljYWwnKTtcbiAgICAgICAgICAgIHkgPSB0aGlzLnkgKyBuZXRIZWlnaHQgLyAyICsgdGhpcy5wYWRkaW5nKCd0b3AnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeDtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzLmhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgeCA9IHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLnBhZGRpbmcoJ3JpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZXMuaGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdmFyIG5ldFdpZHRoID0gdGhpcy53aWR0aCAtIHRoaXMucGFkZGluZygnaG9yaXpvbnRhbCcpO1xuICAgICAgICAgICAgeCA9IHRoaXMueCArIG5ldFdpZHRoIC8gMiArIHRoaXMucGFkZGluZygnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRoaXMueCArIHRoaXMucGFkZGluZygnbGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICB9O1xuICAgIC8vIFRPRE8gKHY0KTogcmVwbGFjZSBwYXJhbWV0ZXJzIHdpdGggb25seSAobGluZUhlaWdodClcbiAgICBDZWxsLnByb3RvdHlwZS5nZXRDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKHNjYWxlRmFjdG9yLCBsaW5lSGVpZ2h0RmFjdG9yKSB7XG4gICAgICAgIGlmIChsaW5lSGVpZ2h0RmFjdG9yID09PSB2b2lkIDApIHsgbGluZUhlaWdodEZhY3RvciA9IDEuMTU7IH1cbiAgICAgICAgdmFyIGxpbmVDb3VudCA9IEFycmF5LmlzQXJyYXkodGhpcy50ZXh0KSA/IHRoaXMudGV4dC5sZW5ndGggOiAxO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9ICh0aGlzLnN0eWxlcy5mb250U2l6ZSAvIHNjYWxlRmFjdG9yKSAqIGxpbmVIZWlnaHRGYWN0b3I7XG4gICAgICAgIHZhciBoZWlnaHQgPSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgdGhpcy5wYWRkaW5nKCd2ZXJ0aWNhbCcpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoaGVpZ2h0LCB0aGlzLnN0eWxlcy5taW5DZWxsSGVpZ2h0KTtcbiAgICB9O1xuICAgIENlbGwucHJvdG90eXBlLnBhZGRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGFkZGluZyA9ICgwLCBjb21tb25fMS5wYXJzZVNwYWNpbmcpKHRoaXMuc3R5bGVzLmNlbGxQYWRkaW5nLCAwKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFkZGluZ1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENlbGw7XG59KCkpO1xuZXhwb3J0cy5DZWxsID0gQ2VsbDtcbnZhciBDb2x1bW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sdW1uKGRhdGFLZXksIHJhdywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pblJlYWRhYmxlV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YUtleSA9IGRhdGFLZXk7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIENvbHVtbi5wcm90b3R5cGUuZ2V0TWF4Q3VzdG9tQ2VsbFdpZHRoID0gZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGFibGUuYWxsUm93cygpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gcm93LmNlbGxzW3RoaXMuaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNlbGwgJiYgdHlwZW9mIGNlbGwuc3R5bGVzLmNlbGxXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGNlbGwuc3R5bGVzLmNlbGxXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9O1xuICAgIHJldHVybiBDb2x1bW47XG59KCkpO1xuZXhwb3J0cy5Db2x1bW4gPSBDb2x1bW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1Njpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmFzc2lnbiA9IHZvaWQgMDtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHMsIHMxLCBzMiwgczMpIHtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAobmV4dFNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG59XG5leHBvcnRzLmFzc2lnbiA9IGFzc2lnbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTcyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVRhYmxlID0gdm9pZCAwO1xudmFyIGRvY3VtZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDQpO1xudmFyIG1vZGVsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xudmFyIHdpZHRoQ2FsY3VsYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjQpO1xudmFyIGNvbmZpZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTYpO1xudmFyIHBvbHlmaWxsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTYpO1xuZnVuY3Rpb24gY3JlYXRlVGFibGUoanNQREZEb2MsIGlucHV0KSB7XG4gICAgdmFyIGRvYyA9IG5ldyBkb2N1bWVudEhhbmRsZXJfMS5Eb2NIYW5kbGVyKGpzUERGRG9jKTtcbiAgICB2YXIgY29udGVudCA9IHBhcnNlQ29udGVudChpbnB1dCwgZG9jLnNjYWxlRmFjdG9yKCkpO1xuICAgIHZhciB0YWJsZSA9IG5ldyBtb2RlbHNfMS5UYWJsZShpbnB1dCwgY29udGVudCk7XG4gICAgKDAsIHdpZHRoQ2FsY3VsYXRvcl8xLmNhbGN1bGF0ZVdpZHRocykoZG9jLCB0YWJsZSk7XG4gICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICByZXR1cm4gdGFibGU7XG59XG5leHBvcnRzLmNyZWF0ZVRhYmxlID0gY3JlYXRlVGFibGU7XG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQoaW5wdXQsIHNmKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBpbnB1dC5jb250ZW50O1xuICAgIHZhciBjb2x1bW5zID0gY3JlYXRlQ29sdW1ucyhjb250ZW50LmNvbHVtbnMpO1xuICAgIC8vIElmIG5vIGhlYWQgb3IgZm9vdCBpcyBzZXQsIHRyeSBnZW5lcmF0aW5nIGl0IHdpdGggY29udGVudCBmcm9tIGNvbHVtbnNcbiAgICBpZiAoY29udGVudC5oZWFkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgc2VjdGlvblJvdyA9IGdlbmVyYXRlU2VjdGlvblJvdyhjb2x1bW5zLCAnaGVhZCcpO1xuICAgICAgICBpZiAoc2VjdGlvblJvdylcbiAgICAgICAgICAgIGNvbnRlbnQuaGVhZC5wdXNoKHNlY3Rpb25Sb3cpO1xuICAgIH1cbiAgICBpZiAoY29udGVudC5mb290Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgc2VjdGlvblJvdyA9IGdlbmVyYXRlU2VjdGlvblJvdyhjb2x1bW5zLCAnZm9vdCcpO1xuICAgICAgICBpZiAoc2VjdGlvblJvdylcbiAgICAgICAgICAgIGNvbnRlbnQuZm9vdC5wdXNoKHNlY3Rpb25Sb3cpO1xuICAgIH1cbiAgICB2YXIgdGhlbWUgPSBpbnB1dC5zZXR0aW5ncy50aGVtZTtcbiAgICB2YXIgc3R5bGVzID0gaW5wdXQuc3R5bGVzO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgIGhlYWQ6IHBhcnNlU2VjdGlvbignaGVhZCcsIGNvbnRlbnQuaGVhZCwgY29sdW1ucywgc3R5bGVzLCB0aGVtZSwgc2YpLFxuICAgICAgICBib2R5OiBwYXJzZVNlY3Rpb24oJ2JvZHknLCBjb250ZW50LmJvZHksIGNvbHVtbnMsIHN0eWxlcywgdGhlbWUsIHNmKSxcbiAgICAgICAgZm9vdDogcGFyc2VTZWN0aW9uKCdmb290JywgY29udGVudC5mb290LCBjb2x1bW5zLCBzdHlsZXMsIHRoZW1lLCBzZiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2VjdGlvbihzZWN0aW9uTmFtZSwgc2VjdGlvblJvd3MsIGNvbHVtbnMsIHN0eWxlUHJvcHMsIHRoZW1lLCBzY2FsZUZhY3Rvcikge1xuICAgIHZhciByb3dTcGFuc0xlZnRGb3JDb2x1bW4gPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0gc2VjdGlvblJvd3MubWFwKGZ1bmN0aW9uIChyYXdSb3csIHJvd0luZGV4KSB7XG4gICAgICAgIHZhciBza2lwcGVkUm93Rm9yUm93U3BhbnMgPSAwO1xuICAgICAgICB2YXIgY2VsbHMgPSB7fTtcbiAgICAgICAgdmFyIGNvbFNwYW5zQWRkZWQgPSAwO1xuICAgICAgICB2YXIgY29sdW1uU3BhbnNMZWZ0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb2x1bW5zXzEgPSBjb2x1bW5zOyBfaSA8IGNvbHVtbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zXzFbX2ldO1xuICAgICAgICAgICAgaWYgKHJvd1NwYW5zTGVmdEZvckNvbHVtbltjb2x1bW4uaW5kZXhdID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICByb3dTcGFuc0xlZnRGb3JDb2x1bW5bY29sdW1uLmluZGV4XS5sZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtblNwYW5zTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3Q2VsbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3Um93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Q2VsbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3Um93W2NvbHVtbi5pbmRleCAtIGNvbFNwYW5zQWRkZWQgLSBza2lwcGVkUm93Rm9yUm93U3BhbnNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Q2VsbCA9IHJhd1Jvd1tjb2x1bW4uZGF0YUtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxJbnB1dFN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJhd0NlbGwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJhd0NlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsSW5wdXRTdHlsZXMgPSAocmF3Q2VsbCA9PT0gbnVsbCB8fCByYXdDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdDZWxsLnN0eWxlcykgfHwge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGNlbGxTdHlsZXMoc2VjdGlvbk5hbWUsIGNvbHVtbiwgcm93SW5kZXgsIHRoZW1lLCBzdHlsZVByb3BzLCBzY2FsZUZhY3RvciwgY2VsbElucHV0U3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBuZXcgbW9kZWxzXzEuQ2VsbChyYXdDZWxsLCBzdHlsZXMsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YUtleSBpcyBub3QgdXNlZCBpbnRlcm5hbGx5IG5vIG1vcmUgYnV0IGtlZXAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgaW4gaG9va3NcbiAgICAgICAgICAgICAgICAgICAgY2VsbHNbY29sdW1uLmRhdGFLZXldID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHNbY29sdW1uLmluZGV4XSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNwYW5zTGVmdCA9IGNlbGwuY29sU3BhbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJvd1NwYW5zTGVmdEZvckNvbHVtbltjb2x1bW4uaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VsbC5yb3dTcGFuIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzOiBjb2x1bW5TcGFuc0xlZnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TcGFuc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbnNBZGRlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvd1NwYW5zTGVmdEZvckNvbHVtbltjb2x1bW4uaW5kZXhdLmxlZnQtLTtcbiAgICAgICAgICAgICAgICBjb2x1bW5TcGFuc0xlZnQgPSByb3dTcGFuc0xlZnRGb3JDb2x1bW5bY29sdW1uLmluZGV4XS50aW1lcztcbiAgICAgICAgICAgICAgICBza2lwcGVkUm93Rm9yUm93U3BhbnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG1vZGVsc18xLlJvdyhyYXdSb3csIHJvd0luZGV4LCBzZWN0aW9uTmFtZSwgY2VsbHMpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNlY3Rpb25Sb3coY29sdW1ucywgc2VjdGlvbikge1xuICAgIHZhciBzZWN0aW9uUm93ID0ge307XG4gICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgaWYgKGNvbC5yYXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gZ2V0U2VjdGlvblRpdGxlKHNlY3Rpb24sIGNvbC5yYXcpO1xuICAgICAgICAgICAgaWYgKHRpdGxlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgc2VjdGlvblJvd1tjb2wuZGF0YUtleV0gPSB0aXRsZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzZWN0aW9uUm93KS5sZW5ndGggPiAwID8gc2VjdGlvblJvdyA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uVGl0bGUoc2VjdGlvbiwgY29sdW1uKSB7XG4gICAgaWYgKHNlY3Rpb24gPT09ICdoZWFkJykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uaGVhZGVyIHx8IGNvbHVtbi50aXRsZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb2x1bW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlY3Rpb24gPT09ICdmb290JyAmJiB0eXBlb2YgY29sdW1uID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gY29sdW1uLmZvb3RlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2x1bW5zKGNvbHVtbnMpIHtcbiAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAga2V5ID0gKF9iID0gKF9hID0gaW5wdXQuZGF0YUtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogaW5wdXQua2V5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbW9kZWxzXzEuQ29sdW1uKGtleSwgaW5wdXQsIGluZGV4KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNlbGxTdHlsZXMoc2VjdGlvbk5hbWUsIGNvbHVtbiwgcm93SW5kZXgsIHRoZW1lTmFtZSwgc3R5bGVzLCBzY2FsZUZhY3RvciwgY2VsbElucHV0U3R5bGVzKSB7XG4gICAgdmFyIHRoZW1lID0gKDAsIGNvbmZpZ18xLmdldFRoZW1lKSh0aGVtZU5hbWUpO1xuICAgIHZhciBzZWN0aW9uU3R5bGVzO1xuICAgIGlmIChzZWN0aW9uTmFtZSA9PT0gJ2hlYWQnKSB7XG4gICAgICAgIHNlY3Rpb25TdHlsZXMgPSBzdHlsZXMuaGVhZFN0eWxlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VjdGlvbk5hbWUgPT09ICdib2R5Jykge1xuICAgICAgICBzZWN0aW9uU3R5bGVzID0gc3R5bGVzLmJvZHlTdHlsZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlY3Rpb25OYW1lID09PSAnZm9vdCcpIHtcbiAgICAgICAgc2VjdGlvblN0eWxlcyA9IHN0eWxlcy5mb290U3R5bGVzO1xuICAgIH1cbiAgICB2YXIgb3RoZXJTdHlsZXMgPSAoMCwgcG9seWZpbGxzXzEuYXNzaWduKSh7fSwgdGhlbWUudGFibGUsIHRoZW1lW3NlY3Rpb25OYW1lXSwgc3R5bGVzLnN0eWxlcywgc2VjdGlvblN0eWxlcyk7XG4gICAgdmFyIGNvbHVtblN0eWxlcyA9IHN0eWxlcy5jb2x1bW5TdHlsZXNbY29sdW1uLmRhdGFLZXldIHx8XG4gICAgICAgIHN0eWxlcy5jb2x1bW5TdHlsZXNbY29sdW1uLmluZGV4XSB8fFxuICAgICAgICB7fTtcbiAgICB2YXIgY29sU3R5bGVzID0gc2VjdGlvbk5hbWUgPT09ICdib2R5JyA/IGNvbHVtblN0eWxlcyA6IHt9O1xuICAgIHZhciByb3dTdHlsZXMgPSBzZWN0aW9uTmFtZSA9PT0gJ2JvZHknICYmIHJvd0luZGV4ICUgMiA9PT0gMFxuICAgICAgICA/ICgwLCBwb2x5ZmlsbHNfMS5hc3NpZ24pKHt9LCB0aGVtZS5hbHRlcm5hdGVSb3csIHN0eWxlcy5hbHRlcm5hdGVSb3dTdHlsZXMpXG4gICAgICAgIDoge307XG4gICAgdmFyIGRlZmF1bHRTdHlsZSA9ICgwLCBjb25maWdfMS5kZWZhdWx0U3R5bGVzKShzY2FsZUZhY3Rvcik7XG4gICAgdmFyIHRoZW1lU3R5bGVzID0gKDAsIHBvbHlmaWxsc18xLmFzc2lnbikoe30sIGRlZmF1bHRTdHlsZSwgb3RoZXJTdHlsZXMsIHJvd1N0eWxlcywgY29sU3R5bGVzKTtcbiAgICByZXR1cm4gKDAsIHBvbHlmaWxsc18xLmFzc2lnbikodGhlbWVTdHlsZXMsIGNlbGxJbnB1dFN0eWxlcyk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY2NDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5hZGRQYWdlID0gZXhwb3J0cy5kcmF3VGFibGUgPSB2b2lkIDA7XG52YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMCk7XG52YXIgbW9kZWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XG52YXIgZG9jdW1lbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NCk7XG52YXIgcG9seWZpbGxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1Nik7XG52YXIgYXV0b1RhYmxlVGV4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpO1xudmFyIHRhYmxlUHJpbnRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQpO1xuZnVuY3Rpb24gZHJhd1RhYmxlKGpzUERGRG9jLCB0YWJsZSkge1xuICAgIHZhciBzZXR0aW5ncyA9IHRhYmxlLnNldHRpbmdzO1xuICAgIHZhciBzdGFydFkgPSBzZXR0aW5ncy5zdGFydFk7XG4gICAgdmFyIG1hcmdpbiA9IHNldHRpbmdzLm1hcmdpbjtcbiAgICB2YXIgY3Vyc29yID0ge1xuICAgICAgICB4OiBtYXJnaW4ubGVmdCxcbiAgICAgICAgeTogc3RhcnRZLFxuICAgIH07XG4gICAgdmFyIHNlY3Rpb25zSGVpZ2h0ID0gdGFibGUuZ2V0SGVhZEhlaWdodCh0YWJsZS5jb2x1bW5zKSArIHRhYmxlLmdldEZvb3RIZWlnaHQodGFibGUuY29sdW1ucyk7XG4gICAgdmFyIG1pblRhYmxlQm90dG9tUG9zID0gc3RhcnRZICsgbWFyZ2luLmJvdHRvbSArIHNlY3Rpb25zSGVpZ2h0O1xuICAgIGlmIChzZXR0aW5ncy5wYWdlQnJlYWsgPT09ICdhdm9pZCcpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0YWJsZS5ib2R5O1xuICAgICAgICB2YXIgdGFibGVIZWlnaHQgPSByb3dzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCByb3cpIHsgcmV0dXJuIGFjYyArIHJvdy5oZWlnaHQ7IH0sIDApO1xuICAgICAgICBtaW5UYWJsZUJvdHRvbVBvcyArPSB0YWJsZUhlaWdodDtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5ldyBkb2N1bWVudEhhbmRsZXJfMS5Eb2NIYW5kbGVyKGpzUERGRG9jKTtcbiAgICBpZiAoc2V0dGluZ3MucGFnZUJyZWFrID09PSAnYWx3YXlzJyB8fFxuICAgICAgICAoc2V0dGluZ3Muc3RhcnRZICE9IG51bGwgJiYgbWluVGFibGVCb3R0b21Qb3MgPiBkb2MucGFnZVNpemUoKS5oZWlnaHQpKSB7XG4gICAgICAgIG5leHRQYWdlKGRvYyk7XG4gICAgICAgIGN1cnNvci55ID0gbWFyZ2luLnRvcDtcbiAgICB9XG4gICAgdGFibGUuY2FsbFdpbGxEcmF3UGFnZUhvb2tzKGRvYywgY3Vyc29yKTtcbiAgICB2YXIgc3RhcnRQb3MgPSAoMCwgcG9seWZpbGxzXzEuYXNzaWduKSh7fSwgY3Vyc29yKTtcbiAgICB0YWJsZS5zdGFydFBhZ2VOdW1iZXIgPSBkb2MucGFnZU51bWJlcigpO1xuICAgIGlmIChzZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrKSB7XG4gICAgICAgIC8vIG1hbmFnZWQgZmxvdyBmb3Igc3BsaXQgY29sdW1uc1xuICAgICAgICBwcmludFRhYmxlV2l0aEhvcml6b250YWxQYWdlQnJlYWsoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBub3JtYWwgZmxvd1xuICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2hvd0hlYWQgPT09ICdmaXJzdFBhZ2UnIHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5zaG93SGVhZCA9PT0gJ2V2ZXJ5UGFnZScpIHtcbiAgICAgICAgICAgIHRhYmxlLmhlYWQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW50Um93KGRvYywgdGFibGUsIHJvdywgY3Vyc29yLCB0YWJsZS5jb2x1bW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgICAgIHRhYmxlLmJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGlzTGFzdFJvdyA9IGluZGV4ID09PSB0YWJsZS5ib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBwcmludEZ1bGxSb3coZG9jLCB0YWJsZSwgcm93LCBpc0xhc3RSb3csIHN0YXJ0UG9zLCBjdXJzb3IsIHRhYmxlLmNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnNob3dGb290ID09PSAnbGFzdFBhZ2UnIHx8IHNldHRpbmdzLnNob3dGb290ID09PSAnZXZlcnlQYWdlJykge1xuICAgICAgICAgICAgdGFibGUuZm9vdC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpbnRSb3coZG9jLCB0YWJsZSwgcm93LCBjdXJzb3IsIHRhYmxlLmNvbHVtbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGNvbW1vbl8xLmFkZFRhYmxlQm9yZGVyKShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yKTtcbiAgICB0YWJsZS5jYWxsRW5kUGFnZUhvb2tzKGRvYywgY3Vyc29yKTtcbiAgICB0YWJsZS5maW5hbFkgPSBjdXJzb3IueTtcbiAgICBqc1BERkRvYy5sYXN0QXV0b1RhYmxlID0gdGFibGU7XG4gICAganNQREZEb2MucHJldmlvdXNBdXRvVGFibGUgPSB0YWJsZTsgLy8gRGVwcmVjYXRlZFxuICAgIGlmIChqc1BERkRvYy5hdXRvVGFibGUpXG4gICAgICAgIGpzUERGRG9jLmF1dG9UYWJsZS5wcmV2aW91cyA9IHRhYmxlOyAvLyBEZXByZWNhdGVkXG4gICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbn1cbmV4cG9ydHMuZHJhd1RhYmxlID0gZHJhd1RhYmxlO1xuZnVuY3Rpb24gcHJpbnRUYWJsZVdpdGhIb3Jpem9udGFsUGFnZUJyZWFrKGRvYywgdGFibGUsIHN0YXJ0UG9zLCBjdXJzb3IpIHtcbiAgICAvLyBjYWxjdWxhdGUgd2lkdGggb2YgY29sdW1ucyBhbmQgcmVuZGVyIG9ubHkgdGhvc2Ugd2hpY2ggY2FuIGZpdCBpbnRvIHBhZ2VcbiAgICB2YXIgYWxsQ29sdW1uc0NhbkZpdFJlc3VsdCA9ICgwLCB0YWJsZVByaW50ZXJfMS5jYWxjdWxhdGVBbGxDb2x1bW5zQ2FuRml0SW5QYWdlKShkb2MsIHRhYmxlKTtcbiAgICB2YXIgc2V0dGluZ3MgPSB0YWJsZS5zZXR0aW5ncztcbiAgICBpZiAoc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVha0JlaGF2aW91ciA9PT0gJ2FmdGVyQWxsUm93cycpIHtcbiAgICAgICAgYWxsQ29sdW1uc0NhbkZpdFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChjb2xzQW5kSW5kZXhlcywgaW5kZXgpIHtcbiAgICAgICAgICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgICAgICAgICAvLyBhZGQgcGFnZSB0byBwcmludCBuZXh0IGNvbHVtbnMgaW4gbmV3IHBhZ2VcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFkZGluZyBhIHBhZ2UgaGVyZSwgbWFrZSBzdXJlIG5vdCB0byBwcmludCB0aGUgZm9vdGVyc1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgcHJpbnRlZCBiZWZvcmUgb24gdGhpcyBzYW1lIGxvb3BcbiAgICAgICAgICAgICAgICBhZGRQYWdlKGRvYywgdGFibGUsIHN0YXJ0UG9zLCBjdXJzb3IsIGNvbHNBbmRJbmRleGVzLmNvbHVtbnMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJpbnQgaGVhZCBmb3Igc2VsZWN0ZWQgY29sdW1uc1xuICAgICAgICAgICAgICAgIHByaW50SGVhZChkb2MsIHRhYmxlLCBjdXJzb3IsIGNvbHNBbmRJbmRleGVzLmNvbHVtbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJpbnQgYm9keSAmIGZvb3RlciBmb3Igc2VsZWN0ZWQgY29sdW1uc1xuICAgICAgICAgICAgcHJpbnRCb2R5KGRvYywgdGFibGUsIHN0YXJ0UG9zLCBjdXJzb3IsIGNvbHNBbmRJbmRleGVzLmNvbHVtbnMpO1xuICAgICAgICAgICAgcHJpbnRGb290KGRvYywgdGFibGUsIGN1cnNvciwgY29sc0FuZEluZGV4ZXMuY29sdW1ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGxhc3RSb3dJbmRleE9mTGFzdFBhZ2VfMSA9IC0xO1xuICAgICAgICB2YXIgZmlyc3RDb2x1bW5zVG9GaXRSZXN1bHQgPSBhbGxDb2x1bW5zQ2FuRml0UmVzdWx0WzBdO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFByaW50IHRoZSBmaXJzdCBjb2x1bW5zLCB0YWtpbmcgbm90ZSBvZiB0aGUgbGFzdCByb3cgcHJpbnRlZFxuICAgICAgICAgICAgdmFyIGxhc3RQcmludGVkUm93SW5kZXggPSBsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzE7XG4gICAgICAgICAgICBpZiAoZmlyc3RDb2x1bW5zVG9GaXRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdENvbHVtbnNUb0ZpdCA9IGZpcnN0Q29sdW1uc1RvRml0UmVzdWx0LmNvbHVtbnM7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RSb3dJbmRleE9mTGFzdFBhZ2VfMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYWRkaW5nIGEgcGFnZSBoZXJlLCBtYWtlIHN1cmUgbm90IHRvIHByaW50IHRoZSBmb290ZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgcHJpbnRlZCBiZWZvcmUgb24gdGhpcyBzYW1lIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgYWRkUGFnZShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBmaXJzdENvbHVtbnNUb0ZpdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmludEhlYWQoZG9jLCB0YWJsZSwgY3Vyc29yLCBmaXJzdENvbHVtbnNUb0ZpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQcmludGVkUm93SW5kZXggPSBwcmludEJvZHlXaXRob3V0UGFnZUJyZWFrcyhkb2MsIHRhYmxlLCBsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzEgKyAxLCBjdXJzb3IsIGZpcnN0Q29sdW1uc1RvRml0KTtcbiAgICAgICAgICAgICAgICBwcmludEZvb3QoZG9jLCB0YWJsZSwgY3Vyc29yLCBmaXJzdENvbHVtbnNUb0ZpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBob3cgbWFueSByb3dzIHdlcmUgcHJpbnRlZCwgc28gdGhhdCB0aGUgbmV4dCBjb2x1bW5zIHdvdWxkIG5vdCBwcmludCBtb3JlIHJvd3MgdGhhbiB0aGF0XG4gICAgICAgICAgICB2YXIgbWF4TnVtYmVyT2ZSb3dzID0gbGFzdFByaW50ZWRSb3dJbmRleCAtIGxhc3RSb3dJbmRleE9mTGFzdFBhZ2VfMTtcbiAgICAgICAgICAgIC8vIFByaW50IHRoZSBuZXh0IGNvbHVtbnMsIG5ldmVyIGV4Y2VkaW5nIG1heE51bWJlck9mUm93c1xuICAgICAgICAgICAgYWxsQ29sdW1uc0NhbkZpdFJlc3VsdC5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2xzQW5kSW5kZXhlcykge1xuICAgICAgICAgICAgICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhZGRpbmcgYSBwYWdlIGhlcmUsIG1ha2Ugc3VyZSBub3QgdG8gcHJpbnQgdGhlIGZvb3RlcnNcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IHByaW50ZWQgYmVmb3JlIG9uIHRoaXMgc2FtZSBsb29wXG4gICAgICAgICAgICAgICAgYWRkUGFnZShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBjb2xzQW5kSW5kZXhlcy5jb2x1bW5zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBwcmludEJvZHlXaXRob3V0UGFnZUJyZWFrcyhkb2MsIHRhYmxlLCBsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzEgKyAxLCBjdXJzb3IsIGNvbHNBbmRJbmRleGVzLmNvbHVtbnMsIG1heE51bWJlck9mUm93cyk7XG4gICAgICAgICAgICAgICAgcHJpbnRGb290KGRvYywgdGFibGUsIGN1cnNvciwgY29sc0FuZEluZGV4ZXMuY29sdW1ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RSb3dJbmRleE9mTGFzdFBhZ2VfMSA9IGxhc3RQcmludGVkUm93SW5kZXg7XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlIChsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzEgPCB0YWJsZS5ib2R5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByaW50SGVhZChkb2MsIHRhYmxlLCBjdXJzb3IsIGNvbHVtbnMpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSB0YWJsZS5zZXR0aW5ncztcbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIGlmIChzZXR0aW5ncy5zaG93SGVhZCA9PT0gJ2ZpcnN0UGFnZScgfHwgc2V0dGluZ3Muc2hvd0hlYWQgPT09ICdldmVyeVBhZ2UnKSB7XG4gICAgICAgIHRhYmxlLmhlYWQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucyk7IH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByaW50Qm9keShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBjb2x1bW5zKSB7XG4gICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICB0YWJsZS5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlzTGFzdFJvdyA9IGluZGV4ID09PSB0YWJsZS5ib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIHByaW50RnVsbFJvdyhkb2MsIHRhYmxlLCByb3csIGlzTGFzdFJvdywgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmludEJvZHlXaXRob3V0UGFnZUJyZWFrcyhkb2MsIHRhYmxlLCBzdGFydFJvd0luZGV4LCBjdXJzb3IsIGNvbHVtbnMsIG1heE51bWJlck9mUm93cykge1xuICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgbWF4TnVtYmVyT2ZSb3dzID0gbWF4TnVtYmVyT2ZSb3dzICE9PSBudWxsICYmIG1heE51bWJlck9mUm93cyAhPT0gdm9pZCAwID8gbWF4TnVtYmVyT2ZSb3dzIDogdGFibGUuYm9keS5sZW5ndGg7XG4gICAgdmFyIGVuZFJvd0luZGV4ID0gTWF0aC5taW4oc3RhcnRSb3dJbmRleCArIG1heE51bWJlck9mUm93cywgdGFibGUuYm9keS5sZW5ndGgpO1xuICAgIHZhciBsYXN0UHJpbnRlZFJvd0luZGV4ID0gLTE7XG4gICAgdGFibGUuYm9keS5zbGljZShzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCkuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgICB2YXIgaXNMYXN0Um93ID0gc3RhcnRSb3dJbmRleCArIGluZGV4ID09PSB0YWJsZS5ib2R5Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciByZW1haW5pbmdTcGFjZSA9IGdldFJlbWFpbmluZ1BhZ2VTcGFjZShkb2MsIHRhYmxlLCBpc0xhc3RSb3csIGN1cnNvcik7XG4gICAgICAgIGlmIChyb3cuY2FuRW50aXJlUm93Rml0KHJlbWFpbmluZ1NwYWNlLCBjb2x1bW5zKSkge1xuICAgICAgICAgICAgcHJpbnRSb3coZG9jLCB0YWJsZSwgcm93LCBjdXJzb3IsIGNvbHVtbnMpO1xuICAgICAgICAgICAgbGFzdFByaW50ZWRSb3dJbmRleCA9IHN0YXJ0Um93SW5kZXggKyBpbmRleDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsYXN0UHJpbnRlZFJvd0luZGV4O1xufVxuZnVuY3Rpb24gcHJpbnRGb290KGRvYywgdGFibGUsIGN1cnNvciwgY29sdW1ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IHRhYmxlLnNldHRpbmdzO1xuICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgaWYgKHNldHRpbmdzLnNob3dGb290ID09PSAnbGFzdFBhZ2UnIHx8IHNldHRpbmdzLnNob3dGb290ID09PSAnZXZlcnlQYWdlJykge1xuICAgICAgICB0YWJsZS5mb290LmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcHJpbnRSb3coZG9jLCB0YWJsZSwgcm93LCBjdXJzb3IsIGNvbHVtbnMpOyB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZW1haW5pbmdMaW5lQ291bnQoY2VsbCwgcmVtYWluaW5nUGFnZVNwYWNlLCBkb2MpIHtcbiAgICB2YXIgbGluZUhlaWdodCA9IGRvYy5nZXRMaW5lSGVpZ2h0KGNlbGwuc3R5bGVzLmZvbnRTaXplKTtcbiAgICB2YXIgdlBhZGRpbmcgPSBjZWxsLnBhZGRpbmcoJ3ZlcnRpY2FsJyk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gTWF0aC5mbG9vcigocmVtYWluaW5nUGFnZVNwYWNlIC0gdlBhZGRpbmcpIC8gbGluZUhlaWdodCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHJlbWFpbmluZ0xpbmVzKTtcbn1cbmZ1bmN0aW9uIG1vZGlmeVJvd1RvRml0KHJvdywgcmVtYWluaW5nUGFnZVNwYWNlLCB0YWJsZSwgZG9jKSB7XG4gICAgdmFyIGNlbGxzID0ge307XG4gICAgcm93LnNwYW5zTXVsdGlwbGVQYWdlcyA9IHRydWU7XG4gICAgcm93LmhlaWdodCA9IDA7XG4gICAgdmFyIHJvd0hlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhYmxlLmNvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBfYVtfaV07XG4gICAgICAgIHZhciBjZWxsID0gcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2VsbC50ZXh0KSkge1xuICAgICAgICAgICAgY2VsbC50ZXh0ID0gW2NlbGwudGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbWFpbmRlckNlbGwgPSBuZXcgbW9kZWxzXzEuQ2VsbChjZWxsLnJhdywgY2VsbC5zdHlsZXMsIGNlbGwuc2VjdGlvbik7XG4gICAgICAgIHJlbWFpbmRlckNlbGwgPSAoMCwgcG9seWZpbGxzXzEuYXNzaWduKShyZW1haW5kZXJDZWxsLCBjZWxsKTtcbiAgICAgICAgcmVtYWluZGVyQ2VsbC50ZXh0ID0gW107XG4gICAgICAgIHZhciByZW1haW5pbmdMaW5lQ291bnQgPSBnZXRSZW1haW5pbmdMaW5lQ291bnQoY2VsbCwgcmVtYWluaW5nUGFnZVNwYWNlLCBkb2MpO1xuICAgICAgICBpZiAoY2VsbC50ZXh0Lmxlbmd0aCA+IHJlbWFpbmluZ0xpbmVDb3VudCkge1xuICAgICAgICAgICAgcmVtYWluZGVyQ2VsbC50ZXh0ID0gY2VsbC50ZXh0LnNwbGljZShyZW1haW5pbmdMaW5lQ291bnQsIGNlbGwudGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IGRvYy5zY2FsZUZhY3RvcigpO1xuICAgICAgICB2YXIgbGluZUhlaWdodEZhY3RvciA9IGRvYy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCk7XG4gICAgICAgIGNlbGwuY29udGVudEhlaWdodCA9IGNlbGwuZ2V0Q29udGVudEhlaWdodChzY2FsZUZhY3RvciwgbGluZUhlaWdodEZhY3Rvcik7XG4gICAgICAgIGlmIChjZWxsLmNvbnRlbnRIZWlnaHQgPj0gcmVtYWluaW5nUGFnZVNwYWNlKSB7XG4gICAgICAgICAgICBjZWxsLmNvbnRlbnRIZWlnaHQgPSByZW1haW5pbmdQYWdlU3BhY2U7XG4gICAgICAgICAgICByZW1haW5kZXJDZWxsLnN0eWxlcy5taW5DZWxsSGVpZ2h0IC09IHJlbWFpbmluZ1BhZ2VTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbC5jb250ZW50SGVpZ2h0ID4gcm93LmhlaWdodCkge1xuICAgICAgICAgICAgcm93LmhlaWdodCA9IGNlbGwuY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZW1haW5kZXJDZWxsLmNvbnRlbnRIZWlnaHQgPSByZW1haW5kZXJDZWxsLmdldENvbnRlbnRIZWlnaHQoc2NhbGVGYWN0b3IsIGxpbmVIZWlnaHRGYWN0b3IpO1xuICAgICAgICBpZiAocmVtYWluZGVyQ2VsbC5jb250ZW50SGVpZ2h0ID4gcm93SGVpZ2h0KSB7XG4gICAgICAgICAgICByb3dIZWlnaHQgPSByZW1haW5kZXJDZWxsLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbHNbY29sdW1uLmluZGV4XSA9IHJlbWFpbmRlckNlbGw7XG4gICAgfVxuICAgIHZhciByZW1haW5kZXJSb3cgPSBuZXcgbW9kZWxzXzEuUm93KHJvdy5yYXcsIC0xLCByb3cuc2VjdGlvbiwgY2VsbHMsIHRydWUpO1xuICAgIHJlbWFpbmRlclJvdy5oZWlnaHQgPSByb3dIZWlnaHQ7XG4gICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRhYmxlLmNvbHVtbnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBfY1tfYl07XG4gICAgICAgIHZhciByZW1haW5kZXJDZWxsID0gcmVtYWluZGVyUm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgIGlmIChyZW1haW5kZXJDZWxsKSB7XG4gICAgICAgICAgICByZW1haW5kZXJDZWxsLmhlaWdodCA9IHJlbWFpbmRlclJvdy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgIGNlbGwuaGVpZ2h0ID0gcm93LmhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtYWluZGVyUm93O1xufVxuZnVuY3Rpb24gc2hvdWxkUHJpbnRPbkN1cnJlbnRQYWdlKGRvYywgcm93LCByZW1haW5pbmdQYWdlU3BhY2UsIHRhYmxlKSB7XG4gICAgdmFyIHBhZ2VIZWlnaHQgPSBkb2MucGFnZVNpemUoKS5oZWlnaHQ7XG4gICAgdmFyIG1hcmdpbiA9IHRhYmxlLnNldHRpbmdzLm1hcmdpbjtcbiAgICB2YXIgbWFyZ2luSGVpZ2h0ID0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b207XG4gICAgdmFyIG1heFJvd0hlaWdodCA9IHBhZ2VIZWlnaHQgLSBtYXJnaW5IZWlnaHQ7XG4gICAgaWYgKHJvdy5zZWN0aW9uID09PSAnYm9keScpIHtcbiAgICAgICAgLy8gU2hvdWxkIGFsc28gdGFrZSBpbnRvIGFjY291bnQgdGhhdCBoZWFkIGFuZCBmb290IGlzIG5vdFxuICAgICAgICAvLyBvbiBldmVyeSBwYWdlIHdpdGggc29tZSBzZXR0aW5nc1xuICAgICAgICBtYXhSb3dIZWlnaHQgLT1cbiAgICAgICAgICAgIHRhYmxlLmdldEhlYWRIZWlnaHQodGFibGUuY29sdW1ucykgKyB0YWJsZS5nZXRGb290SGVpZ2h0KHRhYmxlLmNvbHVtbnMpO1xuICAgIH1cbiAgICB2YXIgbWluUm93SGVpZ2h0ID0gcm93LmdldE1pbmltdW1Sb3dIZWlnaHQodGFibGUuY29sdW1ucywgZG9jKTtcbiAgICB2YXIgbWluUm93Rml0cyA9IG1pblJvd0hlaWdodCA8IHJlbWFpbmluZ1BhZ2VTcGFjZTtcbiAgICBpZiAobWluUm93SGVpZ2h0ID4gbWF4Um93SGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXaWxsIG5vdCBiZSBhYmxlIHRvIHByaW50IHJvdyBcIi5jb25jYXQocm93LmluZGV4LCBcIiBjb3JyZWN0bHkgc2luY2UgaXQncyBtaW5pbXVtIGhlaWdodCBpcyBsYXJnZXIgdGhhbiBwYWdlIGhlaWdodFwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIW1pblJvd0ZpdHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcm93SGFzUm93U3BhbkNlbGwgPSByb3cuaGFzUm93U3Bhbih0YWJsZS5jb2x1bW5zKTtcbiAgICB2YXIgcm93SGlnaGVyVGhhblBhZ2UgPSByb3cuZ2V0TWF4Q2VsbEhlaWdodCh0YWJsZS5jb2x1bW5zKSA+IG1heFJvd0hlaWdodDtcbiAgICBpZiAocm93SGlnaGVyVGhhblBhZ2UpIHtcbiAgICAgICAgaWYgKHJvd0hhc1Jvd1NwYW5DZWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGNvbnRlbnQgb2Ygcm93IFwiLmNvbmNhdChyb3cuaW5kZXgsIFwiIHdpbGwgbm90IGJlIGRyYXduIGNvcnJlY3RseSBzaW5jZSBkcmF3aW5nIHJvd3Mgd2l0aCBhIGhlaWdodCBsYXJnZXIgdGhhbiB0aGUgcGFnZSBoZWlnaHQgYW5kIGhhcyBjZWxscyB3aXRoIHJvd3NwYW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJvd0hhc1Jvd1NwYW5DZWxsKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSBhIG5ldyBwYWdlIGlzIHJlcXVpcmVkIHdoZW5ldmVyIGEgcm93c3BhbiByb3cgZG9uJ3QgZml0IGEgcGFnZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFibGUuc2V0dGluZ3Mucm93UGFnZUJyZWFrID09PSAnYXZvaWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSW4gYWxsIG90aGVyIGNhc2VzIHByaW50IHRoZSByb3cgb24gY3VycmVudCBwYWdlXG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwcmludEZ1bGxSb3coZG9jLCB0YWJsZSwgcm93LCBpc0xhc3RSb3csIHN0YXJ0UG9zLCBjdXJzb3IsIGNvbHVtbnMpIHtcbiAgICB2YXIgcmVtYWluaW5nU3BhY2UgPSBnZXRSZW1haW5pbmdQYWdlU3BhY2UoZG9jLCB0YWJsZSwgaXNMYXN0Um93LCBjdXJzb3IpO1xuICAgIGlmIChyb3cuY2FuRW50aXJlUm93Rml0KHJlbWFpbmluZ1NwYWNlLCBjb2x1bW5zKSkge1xuICAgICAgICAvLyBUaGUgcm93IGZpdHMgaW4gdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNob3VsZFByaW50T25DdXJyZW50UGFnZShkb2MsIHJvdywgcmVtYWluaW5nU3BhY2UsIHRhYmxlKSkge1xuICAgICAgICAvLyBUaGUgcm93IGdldHMgc3BsaXQgaW4gdHdvIGhlcmUsIGVhY2ggcGllY2UgaW4gb25lIHBhZ2VcbiAgICAgICAgdmFyIHJlbWFpbmRlclJvdyA9IG1vZGlmeVJvd1RvRml0KHJvdywgcmVtYWluaW5nU3BhY2UsIHRhYmxlLCBkb2MpO1xuICAgICAgICBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucyk7XG4gICAgICAgIGFkZFBhZ2UoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucyk7XG4gICAgICAgIHByaW50RnVsbFJvdyhkb2MsIHRhYmxlLCByZW1haW5kZXJSb3csIGlzTGFzdFJvdywgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgcm93IGdldCBwcmludGVkIGVudGlyZWxseSBvbiB0aGUgbmV4dCBwYWdlXG4gICAgICAgIGFkZFBhZ2UoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucyk7XG4gICAgICAgIHByaW50RnVsbFJvdyhkb2MsIHRhYmxlLCByb3csIGlzTGFzdFJvdywgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJpbnRSb3coZG9jLCB0YWJsZSwgcm93LCBjdXJzb3IsIGNvbHVtbnMpIHtcbiAgICBjdXJzb3IueCA9IHRhYmxlLnNldHRpbmdzLm1hcmdpbi5sZWZ0O1xuICAgIGZvciAodmFyIF9pID0gMCwgY29sdW1uc18xID0gY29sdW1uczsgX2kgPCBjb2x1bW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zXzFbX2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIGN1cnNvci54ICs9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5hcHBseVN0eWxlcyhjZWxsLnN0eWxlcyk7XG4gICAgICAgIGNlbGwueCA9IGN1cnNvci54O1xuICAgICAgICBjZWxsLnkgPSBjdXJzb3IueTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRhYmxlLmNhbGxDZWxsSG9va3MoZG9jLCB0YWJsZS5ob29rcy53aWxsRHJhd0NlbGwsIGNlbGwsIHJvdywgY29sdW1uLCBjdXJzb3IpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY3Vyc29yLnggKz0gY29sdW1uLndpZHRoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0NlbGxSZWN0KGRvYywgY2VsbCwgY3Vyc29yKTtcbiAgICAgICAgdmFyIHRleHRQb3MgPSBjZWxsLmdldFRleHRQb3MoKTtcbiAgICAgICAgKDAsIGF1dG9UYWJsZVRleHRfMS5kZWZhdWx0KShjZWxsLnRleHQsIHRleHRQb3MueCwgdGV4dFBvcy55LCB7XG4gICAgICAgICAgICBoYWxpZ246IGNlbGwuc3R5bGVzLmhhbGlnbixcbiAgICAgICAgICAgIHZhbGlnbjogY2VsbC5zdHlsZXMudmFsaWduLFxuICAgICAgICAgICAgbWF4V2lkdGg6IE1hdGguY2VpbChjZWxsLndpZHRoIC0gY2VsbC5wYWRkaW5nKCdsZWZ0JykgLSBjZWxsLnBhZGRpbmcoJ3JpZ2h0JykpLFxuICAgICAgICB9LCBkb2MuZ2V0RG9jdW1lbnQoKSk7XG4gICAgICAgIHRhYmxlLmNhbGxDZWxsSG9va3MoZG9jLCB0YWJsZS5ob29rcy5kaWREcmF3Q2VsbCwgY2VsbCwgcm93LCBjb2x1bW4sIGN1cnNvcik7XG4gICAgICAgIGN1cnNvci54ICs9IGNvbHVtbi53aWR0aDtcbiAgICB9XG4gICAgY3Vyc29yLnkgKz0gcm93LmhlaWdodDtcbn1cbmZ1bmN0aW9uIGRyYXdDZWxsUmVjdChkb2MsIGNlbGwsIGN1cnNvcikge1xuICAgIHZhciBjZWxsU3R5bGVzID0gY2VsbC5zdHlsZXM7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbW9uYmVuZ3Rzc29uL2pzUERGLUF1dG9UYWJsZS9pc3N1ZXMvNzc0XG4gICAgLy8gVE9ETyAodjQpOiBiZXR0ZXIgc29sdXRpb24/XG4gICAgZG9jLmdldERvY3VtZW50KCkuc2V0RmlsbENvbG9yKGRvYy5nZXREb2N1bWVudCgpLmdldEZpbGxDb2xvcigpKTtcbiAgICBpZiAodHlwZW9mIGNlbGxTdHlsZXMubGluZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBEcmF3IGNlbGwgYmFja2dyb3VuZCB3aXRoIG5vcm1hbCBib3JkZXJzXG4gICAgICAgIHZhciBmaWxsU3R5bGUgPSAoMCwgY29tbW9uXzEuZ2V0RmlsbFN0eWxlKShjZWxsU3R5bGVzLmxpbmVXaWR0aCwgY2VsbFN0eWxlcy5maWxsQ29sb3IpO1xuICAgICAgICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICBkb2MucmVjdChjZWxsLngsIGN1cnNvci55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCwgZmlsbFN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2VsbFN0eWxlcy5saW5lV2lkdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIERyYXcgY2VsbCBiYWNrZ3JvdW5kXG4gICAgICAgIGlmIChjZWxsU3R5bGVzLmZpbGxDb2xvcikge1xuICAgICAgICAgICAgZG9jLnJlY3QoY2VsbC54LCBjdXJzb3IueSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQsICdGJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyBjZWxsIGluZGl2aWR1YWwgYm9yZGVyc1xuICAgICAgICBkcmF3Q2VsbEJvcmRlcnMoZG9jLCBjZWxsLCBjdXJzb3IsIGNlbGxTdHlsZXMubGluZVdpZHRoKTtcbiAgICB9XG59XG4vKipcbiAqIERyYXcgYWxsIHNwZWNpZmllZCBib3JkZXJzLiBCb3JkZXJzIGFyZSBjZW50ZXJlZCBvbiBjZWxsJ3MgZWRnZSBhbmQgbGVuZ3RoZW5lZFxuICogdG8gb3ZlcmxhcCB3aXRoIG5laWdoYm91cnMgdG8gY3JlYXRlIHNoYXJwIGNvcm5lcnMuXG4gKiBAcGFyYW0gZG9jXG4gKiBAcGFyYW0gY2VsbFxuICogQHBhcmFtIGN1cnNvclxuICogQHBhcmFtIGZpbGxDb2xvclxuICogQHBhcmFtIGxpbmVXaWR0aFxuICovXG5mdW5jdGlvbiBkcmF3Q2VsbEJvcmRlcnMoZG9jLCBjZWxsLCBjdXJzb3IsIGxpbmVXaWR0aCkge1xuICAgIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAobGluZVdpZHRoLnRvcCkge1xuICAgICAgICB4MSA9IGN1cnNvci54O1xuICAgICAgICB5MSA9IGN1cnNvci55O1xuICAgICAgICB4MiA9IGN1cnNvci54ICsgY2VsbC53aWR0aDtcbiAgICAgICAgeTIgPSBjdXJzb3IueTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aC5yaWdodCkge1xuICAgICAgICAgICAgeDIgKz0gMC41ICogbGluZVdpZHRoLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lV2lkdGgubGVmdCkge1xuICAgICAgICAgICAgeDEgLT0gMC41ICogbGluZVdpZHRoLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xpbmUobGluZVdpZHRoLnRvcCwgeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgICBpZiAobGluZVdpZHRoLmJvdHRvbSkge1xuICAgICAgICB4MSA9IGN1cnNvci54O1xuICAgICAgICB5MSA9IGN1cnNvci55ICsgY2VsbC5oZWlnaHQ7XG4gICAgICAgIHgyID0gY3Vyc29yLnggKyBjZWxsLndpZHRoO1xuICAgICAgICB5MiA9IGN1cnNvci55ICsgY2VsbC5oZWlnaHQ7XG4gICAgICAgIGlmIChsaW5lV2lkdGgucmlnaHQpIHtcbiAgICAgICAgICAgIHgyICs9IDAuNSAqIGxpbmVXaWR0aC5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVdpZHRoLmxlZnQpIHtcbiAgICAgICAgICAgIHgxIC09IDAuNSAqIGxpbmVXaWR0aC5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGRyYXdMaW5lKGxpbmVXaWR0aC5ib3R0b20sIHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgaWYgKGxpbmVXaWR0aC5sZWZ0KSB7XG4gICAgICAgIHgxID0gY3Vyc29yLng7XG4gICAgICAgIHkxID0gY3Vyc29yLnk7XG4gICAgICAgIHgyID0gY3Vyc29yLng7XG4gICAgICAgIHkyID0gY3Vyc29yLnkgKyBjZWxsLmhlaWdodDtcbiAgICAgICAgaWYgKGxpbmVXaWR0aC50b3ApIHtcbiAgICAgICAgICAgIHkxIC09IDAuNSAqIGxpbmVXaWR0aC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVXaWR0aC5ib3R0b20pIHtcbiAgICAgICAgICAgIHkyICs9IDAuNSAqIGxpbmVXaWR0aC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xpbmUobGluZVdpZHRoLmxlZnQsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgaWYgKGxpbmVXaWR0aC5yaWdodCkge1xuICAgICAgICB4MSA9IGN1cnNvci54ICsgY2VsbC53aWR0aDtcbiAgICAgICAgeTEgPSBjdXJzb3IueTtcbiAgICAgICAgeDIgPSBjdXJzb3IueCArIGNlbGwud2lkdGg7XG4gICAgICAgIHkyID0gY3Vyc29yLnkgKyBjZWxsLmhlaWdodDtcbiAgICAgICAgaWYgKGxpbmVXaWR0aC50b3ApIHtcbiAgICAgICAgICAgIHkxIC09IDAuNSAqIGxpbmVXaWR0aC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVXaWR0aC5ib3R0b20pIHtcbiAgICAgICAgICAgIHkyICs9IDAuNSAqIGxpbmVXaWR0aC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xpbmUobGluZVdpZHRoLnJpZ2h0LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdMaW5lKHdpZHRoLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBkb2MuZ2V0RG9jdW1lbnQoKS5zZXRMaW5lV2lkdGgod2lkdGgpO1xuICAgICAgICBkb2MuZ2V0RG9jdW1lbnQoKS5saW5lKHgxLCB5MSwgeDIsIHkyLCAnUycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1BhZ2VTcGFjZShkb2MsIHRhYmxlLCBpc0xhc3RSb3csIGN1cnNvcikge1xuICAgIHZhciBib3R0b21Db250ZW50SGVpZ2h0ID0gdGFibGUuc2V0dGluZ3MubWFyZ2luLmJvdHRvbTtcbiAgICB2YXIgc2hvd0Zvb3QgPSB0YWJsZS5zZXR0aW5ncy5zaG93Rm9vdDtcbiAgICBpZiAoc2hvd0Zvb3QgPT09ICdldmVyeVBhZ2UnIHx8IChzaG93Rm9vdCA9PT0gJ2xhc3RQYWdlJyAmJiBpc0xhc3RSb3cpKSB7XG4gICAgICAgIGJvdHRvbUNvbnRlbnRIZWlnaHQgKz0gdGFibGUuZ2V0Rm9vdEhlaWdodCh0YWJsZS5jb2x1bW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYy5wYWdlU2l6ZSgpLmhlaWdodCAtIGN1cnNvci55IC0gYm90dG9tQ29udGVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGFkZFBhZ2UoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucywgc3VwcHJlc3NGb290ZXIpIHtcbiAgICBpZiAoY29sdW1ucyA9PT0gdm9pZCAwKSB7IGNvbHVtbnMgPSBbXTsgfVxuICAgIGlmIChzdXBwcmVzc0Zvb3RlciA9PT0gdm9pZCAwKSB7IHN1cHByZXNzRm9vdGVyID0gZmFsc2U7IH1cbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIGlmICh0YWJsZS5zZXR0aW5ncy5zaG93Rm9vdCA9PT0gJ2V2ZXJ5UGFnZScgJiYgIXN1cHByZXNzRm9vdGVyKSB7XG4gICAgICAgIHRhYmxlLmZvb3QuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucyk7IH0pO1xuICAgIH1cbiAgICAvLyBBZGQgdXNlciBjb250ZW50IGp1c3QgYmVmb3JlIGFkZGluZyBuZXcgcGFnZSBlbnN1cmUgaXQgd2lsbFxuICAgIC8vIGJlIGRyYXduIGFib3ZlIG90aGVyIHRoaW5ncyBvbiB0aGUgcGFnZVxuICAgIHRhYmxlLmNhbGxFbmRQYWdlSG9va3MoZG9jLCBjdXJzb3IpO1xuICAgIHZhciBtYXJnaW4gPSB0YWJsZS5zZXR0aW5ncy5tYXJnaW47XG4gICAgKDAsIGNvbW1vbl8xLmFkZFRhYmxlQm9yZGVyKShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yKTtcbiAgICBuZXh0UGFnZShkb2MpO1xuICAgIHRhYmxlLnBhZ2VOdW1iZXIrKztcbiAgICB0YWJsZS5wYWdlQ291bnQrKztcbiAgICBjdXJzb3IueCA9IG1hcmdpbi5sZWZ0O1xuICAgIGN1cnNvci55ID0gbWFyZ2luLnRvcDtcbiAgICBzdGFydFBvcy55ID0gbWFyZ2luLnRvcDtcbiAgICAvLyBjYWxsIGRpZEFkZFBhZ2UgaG9va3MgYmVmb3JlIGFueSBjb250ZW50IGlzIGFkZGVkIHRvIHRoZSBwYWdlXG4gICAgdGFibGUuY2FsbFdpbGxEcmF3UGFnZUhvb2tzKGRvYywgY3Vyc29yKTtcbiAgICBpZiAodGFibGUuc2V0dGluZ3Muc2hvd0hlYWQgPT09ICdldmVyeVBhZ2UnKSB7XG4gICAgICAgIHRhYmxlLmhlYWQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucyk7IH0pO1xuICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkUGFnZSA9IGFkZFBhZ2U7XG5mdW5jdGlvbiBuZXh0UGFnZShkb2MpIHtcbiAgICB2YXIgY3VycmVudCA9IGRvYy5wYWdlTnVtYmVyKCk7XG4gICAgZG9jLnNldFBhZ2UoY3VycmVudCArIDEpO1xuICAgIHZhciBuZXdDdXJyZW50ID0gZG9jLnBhZ2VOdW1iZXIoKTtcbiAgICBpZiAobmV3Q3VycmVudCA9PT0gY3VycmVudCkge1xuICAgICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMjQ6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY2FsY3VsYXRlQWxsQ29sdW1uc0NhbkZpdEluUGFnZSA9IHZvaWQgMDtcbnZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIwKTtcbi8vIGdldCBjb2x1bW5zIGNhbiBiZSBmaXQgaW50byBwYWdlXG5mdW5jdGlvbiBnZXRDb2x1bW5zQ2FuRml0SW5QYWdlKGRvYywgdGFibGUsIGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAvLyBHZXQgcGFnZSB3aWR0aFxuICAgIHZhciByZW1haW5pbmdXaWR0aCA9ICgwLCBjb21tb25fMS5nZXRQYWdlQXZhaWxhYmxlV2lkdGgpKGRvYywgdGFibGUpO1xuICAgIC8vIEdldCBjb2x1bW4gZGF0YSBrZXkgdG8gcmVwZWF0XG4gICAgdmFyIHJlcGVhdENvbHVtbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGNvbEluZGV4ZXMgPSBbXTtcbiAgICB2YXIgY29sdW1ucyA9IFtdO1xuICAgIHZhciBob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID0gW107XG4gICAgdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YWJsZS5zZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0KSkge1xuICAgICAgICBob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID0gdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdDtcbiAgICAgICAgLy8gSXQgY2FuIGJlIGEgc2luZ2xlIHZhbHVlIG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlciAoZXZlbiBudW1iZXI6IDApXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0YWJsZS5zZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCA9IFt0YWJsZS5zZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0XTtcbiAgICB9XG4gICAgLy8gQ29kZSB0byByZXBlYXQgdGhlIGdpdmVuIGNvbHVtbiBpbiBzcGxpdCBwYWdlc1xuICAgIGhvcml6b250YWxQYWdlQnJlYWtSZXBlYXQuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgdmFyIGNvbCA9IHRhYmxlLmNvbHVtbnMuZmluZChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5kYXRhS2V5ID09PSBmaWVsZCB8fCBpdGVtLmluZGV4ID09PSBmaWVsZDsgfSk7XG4gICAgICAgIGlmIChjb2wgJiYgIXJlcGVhdENvbHVtbnNNYXAuaGFzKGNvbC5pbmRleCkpIHtcbiAgICAgICAgICAgIHJlcGVhdENvbHVtbnNNYXAuc2V0KGNvbC5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb2xJbmRleGVzLnB1c2goY29sLmluZGV4KTtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh0YWJsZS5jb2x1bW5zW2NvbC5pbmRleF0pO1xuICAgICAgICAgICAgcmVtYWluaW5nV2lkdGggLT0gY29sLndyYXBwZWRXaWR0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgdmFyIGkgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IC8vIG1ha2Ugc3VyZSBjb3V0ZXIgaXMgaW5pdGlhdGVkIG91dHNpZGUgdGhlIGxvb3BcbiAgICB3aGlsZSAoaSA8IHRhYmxlLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICBpZiAocmVwZWF0Q29sdW1uc01hcC5oYXMoaSkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xXaWR0aCA9IHRhYmxlLmNvbHVtbnNbaV0ud3JhcHBlZFdpZHRoO1xuICAgICAgICAvLyBUYWtlIGF0IGxlYXN0IG9uZSBjb2x1bW4gZXZlbiBpZiBpdCBkb2Vzbid0IGZpdFxuICAgICAgICBpZiAoZmlyc3QgfHwgcmVtYWluaW5nV2lkdGggPj0gY29sV2lkdGgpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2xJbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2godGFibGUuY29sdW1uc1tpXSk7XG4gICAgICAgICAgICByZW1haW5pbmdXaWR0aCAtPSBjb2xXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHsgY29sSW5kZXhlczogY29sSW5kZXhlcywgY29sdW1uczogY29sdW1ucywgbGFzdEluZGV4OiBpIC0gMSB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQWxsQ29sdW1uc0NhbkZpdEluUGFnZShkb2MsIHRhYmxlKSB7XG4gICAgdmFyIGFsbFJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlLmNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldENvbHVtbnNDYW5GaXRJblBhZ2UoZG9jLCB0YWJsZSwgeyBzdGFydDogaSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdC5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBpID0gcmVzdWx0Lmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsUmVzdWx0cztcbn1cbmV4cG9ydHMuY2FsY3VsYXRlQWxsQ29sdW1uc0NhbkZpdEluUGFnZSA9IGNhbGN1bGF0ZUFsbENvbHVtbnNDYW5GaXRJblBhZ2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMyNDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5lbGxpcHNpemUgPSBleHBvcnRzLnJlc2l6ZUNvbHVtbnMgPSBleHBvcnRzLmNhbGN1bGF0ZVdpZHRocyA9IHZvaWQgMDtcbnZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIwKTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjb2x1bW4gd2lkdGhzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVdpZHRocyhkb2MsIHRhYmxlKSB7XG4gICAgY2FsY3VsYXRlKGRvYywgdGFibGUpO1xuICAgIHZhciByZXNpemFibGVDb2x1bW5zID0gW107XG4gICAgdmFyIGluaXRpYWxUYWJsZVdpZHRoID0gMDtcbiAgICB0YWJsZS5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgY3VzdG9tV2lkdGggPSBjb2x1bW4uZ2V0TWF4Q3VzdG9tQ2VsbFdpZHRoKHRhYmxlKTtcbiAgICAgICAgaWYgKGN1c3RvbVdpZHRoKSB7XG4gICAgICAgICAgICAvLyBmaW5hbCBjb2x1bW4gd2lkdGhcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGN1c3RvbVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5pdGlhbCBjb2x1bW4gd2lkdGggKHdpbGwgYmUgcmVzaXplZClcbiAgICAgICAgICAgIGNvbHVtbi53aWR0aCA9IGNvbHVtbi53cmFwcGVkV2lkdGg7XG4gICAgICAgICAgICByZXNpemFibGVDb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVGFibGVXaWR0aCArPSBjb2x1bW4ud2lkdGg7XG4gICAgfSk7XG4gICAgLy8gd2lkdGggZGlmZmVyZW5jZSB0aGF0IG5lZWRzIHRvIGJlIGRpc3RyaWJ1dGVkXG4gICAgdmFyIHJlc2l6ZVdpZHRoID0gdGFibGUuZ2V0V2lkdGgoZG9jLnBhZ2VTaXplKCkud2lkdGgpIC0gaW5pdGlhbFRhYmxlV2lkdGg7XG4gICAgLy8gZmlyc3QgcmVzaXplIGF0dGVtcHQ6IHdpdGggcmVzcGVjdCB0byBtaW5SZWFkYWJsZVdpZHRoIGFuZCBtaW5XaWR0aFxuICAgIGlmIChyZXNpemVXaWR0aCkge1xuICAgICAgICByZXNpemVXaWR0aCA9IHJlc2l6ZUNvbHVtbnMocmVzaXphYmxlQ29sdW1ucywgcmVzaXplV2lkdGgsIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChjb2x1bW4ubWluUmVhZGFibGVXaWR0aCwgY29sdW1uLm1pbldpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHNlY29uZCByZXNpemUgYXR0ZW1wdDogaWdub3JlIG1pblJlYWRhYmxlV2lkdGggYnV0IHJlc3BlY3QgbWluV2lkdGhcbiAgICBpZiAocmVzaXplV2lkdGgpIHtcbiAgICAgICAgcmVzaXplV2lkdGggPSByZXNpemVDb2x1bW5zKHJlc2l6YWJsZUNvbHVtbnMsIHJlc2l6ZVdpZHRoLCBmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW4ubWluV2lkdGg7IH0pO1xuICAgIH1cbiAgICByZXNpemVXaWR0aCA9IE1hdGguYWJzKHJlc2l6ZVdpZHRoKTtcbiAgICBpZiAoIXRhYmxlLnNldHRpbmdzLmhvcml6b250YWxQYWdlQnJlYWsgJiZcbiAgICAgICAgcmVzaXplV2lkdGggPiAwLjEgLyBkb2Muc2NhbGVGYWN0b3IoKSkge1xuICAgICAgICAvLyBUYWJsZSBjYW4ndCBnZXQgc21hbGxlciBkdWUgdG8gY3VzdG9tLXdpZHRoIG9yIG1pbldpZHRoIHJlc3RyaWN0aW9uc1xuICAgICAgICAvLyBXZSBjYW4ndCByZWFsbHkgZG8gbXVjaCBoZXJlLiBVcCB0byB1c2VyIHRvIGZvciBleGFtcGxlXG4gICAgICAgIC8vIHJlZHVjZSBmb250IHNpemUsIGluY3JlYXNlIHBhZ2Ugc2l6ZSBvciByZW1vdmUgY3VzdG9tIGNlbGwgd2lkdGhzXG4gICAgICAgIC8vIHRvIGFsbG93IG1vcmUgY29sdW1ucyB0byBiZSByZWR1Y2VkIGluIHNpemVcbiAgICAgICAgcmVzaXplV2lkdGggPSByZXNpemVXaWR0aCA8IDEgPyByZXNpemVXaWR0aCA6IE1hdGgucm91bmQocmVzaXplV2lkdGgpO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJPZiB0aGUgdGFibGUgY29udGVudCwgXCIuY29uY2F0KHJlc2l6ZVdpZHRoLCBcIiB1bml0cyB3aWR0aCBjb3VsZCBub3QgZml0IHBhZ2VcIikpO1xuICAgIH1cbiAgICBhcHBseUNvbFNwYW5zKHRhYmxlKTtcbiAgICBmaXRDb250ZW50KHRhYmxlLCBkb2MpO1xuICAgIGFwcGx5Um93U3BhbnModGFibGUpO1xufVxuZXhwb3J0cy5jYWxjdWxhdGVXaWR0aHMgPSBjYWxjdWxhdGVXaWR0aHM7XG5mdW5jdGlvbiBjYWxjdWxhdGUoZG9jLCB0YWJsZSkge1xuICAgIHZhciBzZiA9IGRvYy5zY2FsZUZhY3RvcigpO1xuICAgIHZhciBob3Jpem9udGFsUGFnZUJyZWFrID0gdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVhaztcbiAgICB2YXIgYXZhaWxhYmxlUGFnZVdpZHRoID0gKDAsIGNvbW1vbl8xLmdldFBhZ2VBdmFpbGFibGVXaWR0aCkoZG9jLCB0YWJsZSk7XG4gICAgdGFibGUuYWxsUm93cygpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGFibGUuY29sdW1uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gdGFibGUuaG9va3MuZGlkUGFyc2VDZWxsO1xuICAgICAgICAgICAgdGFibGUuY2FsbENlbGxIb29rcyhkb2MsIGhvb2tzLCBjZWxsLCByb3csIGNvbHVtbiwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IGNlbGwucGFkZGluZygnaG9yaXpvbnRhbCcpO1xuICAgICAgICAgICAgY2VsbC5jb250ZW50V2lkdGggPSAoMCwgY29tbW9uXzEuZ2V0U3RyaW5nV2lkdGgpKGNlbGwudGV4dCwgY2VsbC5zdHlsZXMsIGRvYykgKyBwYWRkaW5nO1xuICAgICAgICAgICAgLy8gVXNpbmcgW15cXFNcXHUwMEEwXSBpbnN0ZWFkIG9mIFxccyBlbnN1cmVzIHRoYXQgd2Ugc3BsaXQgdGhlIHRleHQgb24gYWxsXG4gICAgICAgICAgICAvLyB3aGl0ZXNwYWNlIGV4Y2VwdCBub24tYnJlYWtpbmcgc3BhY2VzIChcXHUwMEEwKS4gV2UgbmVlZCB0byBwcmVzZXJ2ZVxuICAgICAgICAgICAgLy8gdGhlbSBpbiB0aGUgc3BsaXQgcHJvY2VzcyB0byBlbnN1cmUgY29ycmVjdCB3b3JkIHNlcGFyYXRpb24gYW5kIHdpZHRoXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgIHZhciBsb25nZXN0V29yZFdpZHRoID0gKDAsIGNvbW1vbl8xLmdldFN0cmluZ1dpZHRoKShjZWxsLnRleHQuam9pbignICcpLnNwbGl0KC9bXlxcU1xcdTAwQTBdKy8pLCBjZWxsLnN0eWxlcywgZG9jKTtcbiAgICAgICAgICAgIGNlbGwubWluUmVhZGFibGVXaWR0aCA9IGxvbmdlc3RXb3JkV2lkdGggKyBjZWxsLnBhZGRpbmcoJ2hvcml6b250YWwnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbC5zdHlsZXMuY2VsbFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNlbGwubWluV2lkdGggPSBjZWxsLnN0eWxlcy5jZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgY2VsbC53cmFwcGVkV2lkdGggPSBjZWxsLnN0eWxlcy5jZWxsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjZWxsLnN0eWxlcy5jZWxsV2lkdGggPT09ICd3cmFwJyB8fFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxQYWdlQnJlYWsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBjZWxsIHdpZHRoIHNob3VsZCBub3QgYmUgbW9yZSB0aGFuIGF2YWlsYWJsZSBwYWdlIHdpZHRoXG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuY29udGVudFdpZHRoID4gYXZhaWxhYmxlUGFnZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwubWluV2lkdGggPSBhdmFpbGFibGVQYWdlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwud3JhcHBlZFdpZHRoID0gYXZhaWxhYmxlUGFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5taW5XaWR0aCA9IGNlbGwuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLndyYXBwZWRXaWR0aCA9IGNlbGwuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGF1dG9cbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE1pbldpZHRoID0gMTAgLyBzZjtcbiAgICAgICAgICAgICAgICBjZWxsLm1pbldpZHRoID0gY2VsbC5zdHlsZXMubWluQ2VsbFdpZHRoIHx8IGRlZmF1bHRNaW5XaWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsLndyYXBwZWRXaWR0aCA9IGNlbGwuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLm1pbldpZHRoID4gY2VsbC53cmFwcGVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC53cmFwcGVkV2lkdGggPSBjZWxsLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmFsbFJvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhYmxlLmNvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIC8vIEZvciBub3cgd2UgaWdub3JlIHRoZSBtaW5XaWR0aCBhbmQgd3JhcHBlZFdpZHRoIG9mIGNvbHNwYW4gY2VsbHMgd2hlbiBjYWxjdWxhdGluZyBjb2xzcGFuIHdpZHRocy5cbiAgICAgICAgICAgIC8vIENvdWxkIHByb2JhYmx5IGJlIGltcHJvdmVkIHVwb24gaG93ZXZlci5cbiAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuY29sU3BhbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi53cmFwcGVkV2lkdGggPSBNYXRoLm1heChjb2x1bW4ud3JhcHBlZFdpZHRoLCBjZWxsLndyYXBwZWRXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29sdW1uLm1pbldpZHRoID0gTWF0aC5tYXgoY29sdW1uLm1pbldpZHRoLCBjZWxsLm1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4ubWluUmVhZGFibGVXaWR0aCA9IE1hdGgubWF4KGNvbHVtbi5taW5SZWFkYWJsZVdpZHRoLCBjZWxsLm1pblJlYWRhYmxlV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzcGVjdCBjZWxsV2lkdGggc2V0IGluIGNvbHVtblN0eWxlcyBldmVuIGlmIHRoZXJlIGlzIG5vIGNlbGxzIGZvciB0aGlzIGNvbHVtblxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBjb2x1bW4gb25seSBoYXZlIGNvbHNwYW4gY2VsbHMuIFNpbmNlIHRoZSB3aWR0aCBvZiBjb2xzcGFuIGNlbGxzXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWZmZWN0IHRoZSB3aWR0aCBvZiBjb2x1bW5zLCBzZXR0aW5nIGNvbHVtblN0eWxlcyBjZWxsV2lkdGggZW5hYmxlcyB0aGVcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHRvIGF0IGxlYXN0IGRvIGl0IG1hbnVhbGx5LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBwZXJmZWN0IGZvciBub3cgc2luY2UgZm9yIGV4YW1wbGUgcm93IGFuZCB0YWJsZSBzdHlsZXMgYXJlXG4gICAgICAgICAgICAgICAgLy8gbm90IGFjY291bnRlZCBmb3JcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uU3R5bGVzID0gdGFibGUuc3R5bGVzLmNvbHVtblN0eWxlc1tjb2x1bW4uZGF0YUtleV0gfHxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuc3R5bGVzLmNvbHVtblN0eWxlc1tjb2x1bW4uaW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICAgICAgICAgIHZhciBjZWxsV2lkdGggPSBjb2x1bW5TdHlsZXMuY2VsbFdpZHRoIHx8IGNvbHVtblN0eWxlcy5taW5DZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxXaWR0aCAmJiB0eXBlb2YgY2VsbFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWluV2lkdGggPSBjZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi53cmFwcGVkV2lkdGggPSBjZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGNvbHVtbnMgZ2V0IGF0IGxlYXN0IG1pbiB3aWR0aCBldmVuIHRob3VnaCB3aWR0aCBjYWxjdWxhdGlvbnMgYXJlIG5vdCBiYXNlZCBvbiB0aGVtXG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuY29sU3BhbiA+IDEgJiYgIWNvbHVtbi5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWluV2lkdGggPSBjZWxsLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5jb2xTcGFuID4gMSAmJiAhY29sdW1uLndyYXBwZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud3JhcHBlZFdpZHRoID0gY2VsbC5taW5XaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogRGlzdHJpYnV0ZSByZXNpemVXaWR0aCBvbiBwYXNzZWQgcmVzaXphYmxlIGNvbHVtbnNcbiAqL1xuZnVuY3Rpb24gcmVzaXplQ29sdW1ucyhjb2x1bW5zLCByZXNpemVXaWR0aCwgZ2V0TWluV2lkdGgpIHtcbiAgICB2YXIgaW5pdGlhbFJlc2l6ZVdpZHRoID0gcmVzaXplV2lkdGg7XG4gICAgdmFyIHN1bVdyYXBwZWRXaWR0aCA9IGNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikgeyByZXR1cm4gYWNjICsgY29sdW1uLndyYXBwZWRXaWR0aDsgfSwgMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICB2YXIgcmF0aW8gPSBjb2x1bW4ud3JhcHBlZFdpZHRoIC8gc3VtV3JhcHBlZFdpZHRoO1xuICAgICAgICB2YXIgc3VnZ2VzdGVkQ2hhbmdlID0gaW5pdGlhbFJlc2l6ZVdpZHRoICogcmF0aW87XG4gICAgICAgIHZhciBzdWdnZXN0ZWRXaWR0aCA9IGNvbHVtbi53aWR0aCArIHN1Z2dlc3RlZENoYW5nZTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0gZ2V0TWluV2lkdGgoY29sdW1uKTtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gc3VnZ2VzdGVkV2lkdGggPCBtaW5XaWR0aCA/IG1pbldpZHRoIDogc3VnZ2VzdGVkV2lkdGg7XG4gICAgICAgIHJlc2l6ZVdpZHRoIC09IG5ld1dpZHRoIC0gY29sdW1uLndpZHRoO1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBuZXdXaWR0aDtcbiAgICB9XG4gICAgcmVzaXplV2lkdGggPSBNYXRoLnJvdW5kKHJlc2l6ZVdpZHRoICogMWUxMCkgLyAxZTEwO1xuICAgIC8vIFJ1biB0aGUgcmVzaXplciBhZ2FpbiBpZiB0aGVyZSdzIHJlbWFpbmluZyB3aWR0aCBuZWVkc1xuICAgIC8vIHRvIGJlIGRpc3RyaWJ1dGVkIGFuZCB0aGVyZSdyZSBjb2x1bW5zIHRoYXQgY2FuIGJlIHJlc2l6ZWRcbiAgICBpZiAocmVzaXplV2lkdGgpIHtcbiAgICAgICAgdmFyIHJlc2l6YWJsZUNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzaXplV2lkdGggPCAwXG4gICAgICAgICAgICAgICAgPyBjb2x1bW4ud2lkdGggPiBnZXRNaW5XaWR0aChjb2x1bW4pIC8vIGNoZWNrIGlmIGNvbHVtbiBjYW4gc2hyaW5rXG4gICAgICAgICAgICAgICAgOiB0cnVlOyAvLyBjaGVjayBpZiBjb2x1bW4gY2FuIGdyb3dcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNpemFibGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzaXplV2lkdGggPSByZXNpemVDb2x1bW5zKHJlc2l6YWJsZUNvbHVtbnMsIHJlc2l6ZVdpZHRoLCBnZXRNaW5XaWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2l6ZVdpZHRoO1xufVxuZXhwb3J0cy5yZXNpemVDb2x1bW5zID0gcmVzaXplQ29sdW1ucztcbmZ1bmN0aW9uIGFwcGx5Um93U3BhbnModGFibGUpIHtcbiAgICB2YXIgcm93U3BhbkNlbGxzID0ge307XG4gICAgdmFyIGNvbFJvd1NwYW5zTGVmdCA9IDE7XG4gICAgdmFyIGFsbCA9IHRhYmxlLmFsbFJvd3MoKTtcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgYWxsLmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgICB2YXIgcm93ID0gYWxsW3Jvd0luZGV4XTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhYmxlLmNvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByb3dTcGFuQ2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIGlmIChjb2xSb3dTcGFuc0xlZnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29sUm93U3BhbnNMZWZ0LS07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEuY2VsbC5oZWlnaHQgKz0gcm93LmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb2xSb3dTcGFuc0xlZnQgPSBkYXRhLmNlbGwuY29sU3BhbjtcbiAgICAgICAgICAgICAgICBkZWxldGUgcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICAgICAgZGF0YS5sZWZ0LS07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVmdCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByb3dTcGFuQ2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbC5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnJvd1NwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBhbGwubGVuZ3RoIC0gcm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gY2VsbC5yb3dTcGFuID4gcmVtYWluaW5nID8gcmVtYWluaW5nIDogY2VsbC5yb3dTcGFuO1xuICAgICAgICAgICAgICAgICAgICByb3dTcGFuQ2VsbHNbY29sdW1uLmluZGV4XSA9IHsgY2VsbDogY2VsbCwgbGVmdDogbGVmdCwgcm93OiByb3cgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUNvbFNwYW5zKHRhYmxlKSB7XG4gICAgdmFyIGFsbCA9IHRhYmxlLmFsbFJvd3MoKTtcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgYWxsLmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgICB2YXIgcm93ID0gYWxsW3Jvd0luZGV4XTtcbiAgICAgICAgdmFyIGNvbFNwYW5DZWxsID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbWJpbmVkQ29sU3BhbldpZHRoID0gMDtcbiAgICAgICAgdmFyIGNvbFNwYW5zTGVmdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCB0YWJsZS5jb2x1bW5zLmxlbmd0aDsgY29sdW1uSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRhYmxlLmNvbHVtbnNbY29sdW1uSW5kZXhdO1xuICAgICAgICAgICAgLy8gV2lkdGggYW5kIGNvbHNwYW5cbiAgICAgICAgICAgIGNvbFNwYW5zTGVmdCAtPSAxO1xuICAgICAgICAgICAgaWYgKGNvbFNwYW5zTGVmdCA+IDEgJiYgdGFibGUuY29sdW1uc1tjb2x1bW5JbmRleCArIDFdKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZWRDb2xTcGFuV2lkdGggKz0gY29sdW1uLndpZHRoO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbFNwYW5DZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBjb2xTcGFuQ2VsbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICAgICAgY29sU3BhbkNlbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNlbGwud2lkdGggPSBjb2x1bW4ud2lkdGggKyBjb21iaW5lZENvbFNwYW5XaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb2xTcGFuc0xlZnQgPSBjZWxsLmNvbFNwYW47XG4gICAgICAgICAgICAgICAgY29tYmluZWRDb2xTcGFuV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmNvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbFNwYW5DZWxsID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWRDb2xTcGFuV2lkdGggKz0gY29sdW1uLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VsbC53aWR0aCA9IGNvbHVtbi53aWR0aCArIGNvbWJpbmVkQ29sU3BhbldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZml0Q29udGVudCh0YWJsZSwgZG9jKSB7XG4gICAgdmFyIHJvd1NwYW5IZWlnaHQgPSB7IGNvdW50OiAwLCBoZWlnaHQ6IDAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGFibGUuYWxsUm93cygpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcm93ID0gX2FbX2ldO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGFibGUuY29sdW1uczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfY1tfYl07XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGNlbGwuc3R5bGVzLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB0ZXh0U3BhY2UgPSBjZWxsLndpZHRoIC0gY2VsbC5wYWRkaW5nKCdob3Jpem9udGFsJyk7XG4gICAgICAgICAgICBpZiAoY2VsbC5zdHlsZXMub3ZlcmZsb3cgPT09ICdsaW5lYnJlYWsnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG9uZSBwdCB0byB0ZXh0U3BhY2UgdG8gZml4IHJvdW5kaW5nIGVycm9yXG4gICAgICAgICAgICAgICAgY2VsbC50ZXh0ID0gZG9jLnNwbGl0VGV4dFRvU2l6ZShjZWxsLnRleHQsIHRleHRTcGFjZSArIDEgLyBkb2Muc2NhbGVGYWN0b3IoKSwgeyBmb250U2l6ZTogY2VsbC5zdHlsZXMuZm9udFNpemUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjZWxsLnN0eWxlcy5vdmVyZmxvdyA9PT0gJ2VsbGlwc2l6ZScpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnRleHQgPSBlbGxpcHNpemUoY2VsbC50ZXh0LCB0ZXh0U3BhY2UsIGNlbGwuc3R5bGVzLCBkb2MsICcuLi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNlbGwuc3R5bGVzLm92ZXJmbG93ID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgIGNlbGwudGV4dCA9IGVsbGlwc2l6ZShjZWxsLnRleHQsIHRleHRTcGFjZSwgY2VsbC5zdHlsZXMsIGRvYywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNlbGwuc3R5bGVzLm92ZXJmbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNlbGwuc3R5bGVzLm92ZXJmbG93KGNlbGwudGV4dCwgdGV4dFNwYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC50ZXh0ID0gW3Jlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnRleHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbC5jb250ZW50SGVpZ2h0ID0gY2VsbC5nZXRDb250ZW50SGVpZ2h0KGRvYy5zY2FsZUZhY3RvcigpLCBkb2MuZ2V0TGluZUhlaWdodEZhY3RvcigpKTtcbiAgICAgICAgICAgIHZhciByZWFsQ29udGVudEhlaWdodCA9IGNlbGwuY29udGVudEhlaWdodCAvIGNlbGwucm93U3BhbjtcbiAgICAgICAgICAgIGlmIChjZWxsLnJvd1NwYW4gPiAxICYmXG4gICAgICAgICAgICAgICAgcm93U3BhbkhlaWdodC5jb3VudCAqIHJvd1NwYW5IZWlnaHQuaGVpZ2h0IDxcbiAgICAgICAgICAgICAgICAgICAgcmVhbENvbnRlbnRIZWlnaHQgKiBjZWxsLnJvd1NwYW4pIHtcbiAgICAgICAgICAgICAgICByb3dTcGFuSGVpZ2h0ID0geyBoZWlnaHQ6IHJlYWxDb250ZW50SGVpZ2h0LCBjb3VudDogY2VsbC5yb3dTcGFuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb3dTcGFuSGVpZ2h0ICYmIHJvd1NwYW5IZWlnaHQuY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1NwYW5IZWlnaHQuaGVpZ2h0ID4gcmVhbENvbnRlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbENvbnRlbnRIZWlnaHQgPSByb3dTcGFuSGVpZ2h0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVhbENvbnRlbnRIZWlnaHQgPiByb3cuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcm93LmhlaWdodCA9IHJlYWxDb250ZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvd1NwYW5IZWlnaHQuY291bnQtLTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGxpcHNpemUodGV4dCwgd2lkdGgsIHN0eWxlcywgZG9jLCBvdmVyZmxvdykge1xuICAgIHJldHVybiB0ZXh0Lm1hcChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbGxpcHNpemVTdHIoc3RyLCB3aWR0aCwgc3R5bGVzLCBkb2MsIG92ZXJmbG93KTsgfSk7XG59XG5leHBvcnRzLmVsbGlwc2l6ZSA9IGVsbGlwc2l6ZTtcbmZ1bmN0aW9uIGVsbGlwc2l6ZVN0cih0ZXh0LCB3aWR0aCwgc3R5bGVzLCBkb2MsIG92ZXJmbG93KSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IDEwMDAwICogZG9jLnNjYWxlRmFjdG9yKCk7XG4gICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgIGlmICh3aWR0aCA+PSAoMCwgY29tbW9uXzEuZ2V0U3RyaW5nV2lkdGgpKHRleHQsIHN0eWxlcywgZG9jKSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgd2hpbGUgKHdpZHRoIDwgKDAsIGNvbW1vbl8xLmdldFN0cmluZ1dpZHRoKSh0ZXh0ICsgb3ZlcmZsb3csIHN0eWxlcywgZG9jKSkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0LnRyaW0oKSArIG92ZXJmbG93O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NjQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbmlmKHR5cGVvZiBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX185NjRfXyA9PT0gJ3VuZGVmaW5lZCcpIHsgdmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ3VuZGVmaW5lZCdcIik7IGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJzsgdGhyb3cgZTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzk2NF9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4hZnVuY3Rpb24oKSB7XG52YXIgZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX187XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DZWxsID0gZXhwb3J0cy5Db2x1bW4gPSBleHBvcnRzLlJvdyA9IGV4cG9ydHMuVGFibGUgPSBleHBvcnRzLkNlbGxIb29rRGF0YSA9IGV4cG9ydHMuX19kcmF3VGFibGUgPSBleHBvcnRzLl9fY3JlYXRlVGFibGUgPSBleHBvcnRzLmFwcGx5UGx1Z2luID0gdm9pZCAwO1xudmFyIGFwcGx5UGx1Z2luXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0MCk7XG52YXIgaW5wdXRQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzc2KTtcbnZhciB0YWJsZURyYXdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjQpO1xudmFyIHRhYmxlQ2FsY3VsYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NzIpO1xudmFyIG1vZGVsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGFibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbHNfMS5UYWJsZTsgfSB9KSk7XG52YXIgSG9va0RhdGFfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNlbGxIb29rRGF0YVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhvb2tEYXRhXzEuQ2VsbEhvb2tEYXRhOyB9IH0pKTtcbnZhciBtb2RlbHNfMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNlbGxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbHNfMi5DZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbHVtblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZGVsc18yLkNvbHVtbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3dcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbHNfMi5Sb3c7IH0gfSkpO1xuLy8gZXhwb3J0IHsgYXBwbHlQbHVnaW4gfSBkaWRuJ3QgZXhwb3J0IGFwcGx5UGx1Z2luXG4vLyB0byBpbmRleC5kLnRzIGZvciBzb21lIHJlYXNvblxuZnVuY3Rpb24gYXBwbHlQbHVnaW4oanNQREYpIHtcbiAgICAoMCwgYXBwbHlQbHVnaW5fMS5kZWZhdWx0KShqc1BERik7XG59XG5leHBvcnRzLmFwcGx5UGx1Z2luID0gYXBwbHlQbHVnaW47XG5mdW5jdGlvbiBhdXRvVGFibGUoZCwgb3B0aW9ucykge1xuICAgIHZhciBpbnB1dCA9ICgwLCBpbnB1dFBhcnNlcl8xLnBhcnNlSW5wdXQpKGQsIG9wdGlvbnMpO1xuICAgIHZhciB0YWJsZSA9ICgwLCB0YWJsZUNhbGN1bGF0b3JfMS5jcmVhdGVUYWJsZSkoZCwgaW5wdXQpO1xuICAgICgwLCB0YWJsZURyYXdlcl8xLmRyYXdUYWJsZSkoZCwgdGFibGUpO1xufVxuLy8gRXhwZXJpbWVudGFsIGV4cG9ydFxuZnVuY3Rpb24gX19jcmVhdGVUYWJsZShkLCBvcHRpb25zKSB7XG4gICAgdmFyIGlucHV0ID0gKDAsIGlucHV0UGFyc2VyXzEucGFyc2VJbnB1dCkoZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgwLCB0YWJsZUNhbGN1bGF0b3JfMS5jcmVhdGVUYWJsZSkoZCwgaW5wdXQpO1xufVxuZXhwb3J0cy5fX2NyZWF0ZVRhYmxlID0gX19jcmVhdGVUYWJsZTtcbmZ1bmN0aW9uIF9fZHJhd1RhYmxlKGQsIHRhYmxlKSB7XG4gICAgKDAsIHRhYmxlRHJhd2VyXzEuZHJhd1RhYmxlKShkLCB0YWJsZSk7XG59XG5leHBvcnRzLl9fZHJhd1RhYmxlID0gX19kcmF3VGFibGU7XG50cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgdmFyIGpzUERGID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjQpO1xuICAgIC8vIFdlYnBhY2sgaW1wb3J0ZWQganNwZGYgaW5zdGVhZCBvZiBqc1BERiBmb3Igc29tZSByZWFzb25cbiAgICAvLyB3aGlsZSBpdCBzZWVtZWQgdG8gd29yayBldmVyeXdoZXJlIGVsc2UuXG4gICAgaWYgKGpzUERGLmpzUERGKVxuICAgICAgICBqc1BERiA9IGpzUERGLmpzUERGO1xuICAgIGFwcGx5UGx1Z2luKGpzUERGKTtcbn1cbmNhdGNoIChlcnJvcikge1xuICAgIC8vIEltcG9ydGluZyBqc3BkZiBpbiBub2RlanMgZW52aXJvbm1lbnRzIGRvZXMgbm90IHdvcmsgYXMgb2YganNwZGZcbiAgICAvLyAxLjUuMyBzbyB3ZSBuZWVkIHRvIHNpbGVuY2UgcG90ZW50aWFsIGVycm9ycyB0byBzdXBwb3J0IHVzaW5nIGZvciBleGFtcGxlXG4gICAgLy8gdGhlIG5vZGVqcyBqc3BkZiBkaXN0IGZpbGVzIHdpdGggdGhlIGV4cG9ydGVkIGFwcGx5UGx1Z2luXG59XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGF1dG9UYWJsZTtcblxufSgpO1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsIndlYnBhY2tMb2FkT3B0aW9uYWxFeHRlcm5hbE1vZHVsZSIsInJlcXVpcmUiLCJlIiwiZGVmaW5lIiwiYW1kIiwiYSIsImkiLCJnbG9iYWxUaGlzIiwid2luZG93Iiwic2VsZiIsImdsb2JhbCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzk2NF9fIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX19leHRlbmRzIiwiZXh0ZW5kU3RhdGljcyIsImQiLCJiIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJfXyIsImNvbnN0cnVjdG9yIiwiY3JlYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIkNlbGxIb29rRGF0YSIsIkhvb2tEYXRhIiwiZG9jIiwidGFibGUiLCJjdXJzb3IiLCJwYWdlTnVtYmVyIiwicGFnZUNvdW50Iiwic2V0dGluZ3MiLCJnZXREb2N1bWVudCIsIl9zdXBlciIsImNlbGwiLCJyb3ciLCJjb2x1bW4iLCJfdGhpcyIsInNlY3Rpb24iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiaHRtbFBhcnNlcl8xIiwiYXV0b1RhYmxlVGV4dF8xIiwiZG9jdW1lbnRIYW5kbGVyXzEiLCJpbnB1dFBhcnNlcl8xIiwidGFibGVEcmF3ZXJfMSIsInRhYmxlQ2FsY3VsYXRvcl8xIiwiZGVmYXVsdF8xIiwianNQREYiLCJBUEkiLCJhdXRvVGFibGUiLCJhcmdzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJvcHRpb25zIiwiY29uc29sZSIsImVycm9yIiwiY29sdW1ucyIsImJvZHkiLCJpbnB1dCIsInBhcnNlSW5wdXQiLCJjcmVhdGVUYWJsZSIsImRyYXdUYWJsZSIsImxhc3RBdXRvVGFibGUiLCJwcmV2aW91c0F1dG9UYWJsZSIsInByZXZpb3VzIiwiYXV0b1RhYmxlVGV4dCIsInRleHQiLCJ4IiwieSIsInN0eWxlcyIsImRlZmF1bHQiLCJhdXRvVGFibGVTZXREZWZhdWx0cyIsImRlZmF1bHRzIiwiRG9jSGFuZGxlciIsInNldERlZmF1bHRzIiwiYXV0b1RhYmxlSHRtbFRvSnNvbiIsInRhYmxlRWxlbSIsImluY2x1ZGVIaWRkZW5FbGVtZW50cyIsIl9hIiwiX2IiLCJwYXJzZUh0bWwiLCJoZWFkIiwibWFwIiwiYyIsImNvbnRlbnQiLCJyb3dzIiwiZGF0YSIsImF1dG9UYWJsZUVuZFBvc1kiLCJwcmV2IiwiZmluYWxZIiwiYXV0b1RhYmxlQWRkUGFnZUNvbnRlbnQiLCJob29rIiwiZ2xvYmFsRGVmYXVsdHMiLCJhZGRQYWdlQ29udGVudCIsImF1dG9UYWJsZUFkZFBhZ2UiLCJhZGRQYWdlIiwiUEhZU0lDQUxfTElORV9IRUlHSFQiLCJrIiwiaW50ZXJuYWwiLCJzY2FsZUZhY3RvciIsImZvbnRTaXplIiwiZ2V0Rm9udFNpemUiLCJsaW5lSGVpZ2h0RmFjdG9yIiwiZ2V0TGluZUhlaWdodEZhY3RvciIsImxpbmVIZWlnaHQiLCJzcGxpdFJlZ2V4Iiwic3BsaXRUZXh0IiwibGluZUNvdW50IiwidmFsaWduIiwiaGFsaWduIiwic3BsaXQiLCJhbGlnblNpemUiLCJpTGluZSIsImdldFN0cmluZ1VuaXRXaWR0aCIsIm1heFdpZHRoIiwiYWxpZ24iLCJnZXRQYWdlQXZhaWxhYmxlV2lkdGgiLCJwYXJzZVNwYWNpbmciLCJnZXRGaWxsU3R5bGUiLCJhZGRUYWJsZUJvcmRlciIsImdldFN0cmluZ1dpZHRoIiwiYXBwbHlTdHlsZXMiLCJ0ZXh0QXJyIiwiaXNBcnJheSIsIndpZGVzdExpbmVXaWR0aCIsImdldFRleHRXaWR0aCIsInJlZHVjZSIsIk1hdGgiLCJtYXgiLCJzdGFydFBvcyIsImxpbmVXaWR0aCIsInRhYmxlTGluZVdpZHRoIiwibGluZUNvbG9yIiwidGFibGVMaW5lQ29sb3IiLCJmaWxsU3R5bGUiLCJyZWN0IiwiZ2V0V2lkdGgiLCJwYWdlU2l6ZSIsIndpZHRoIiwiZmlsbENvbG9yIiwiZHJhd0xpbmUiLCJkcmF3QmFja2dyb3VuZCIsImRlZmF1bHRWYWx1ZSIsIl9jIiwiX2QiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ2ZXJ0aWNhbCIsImhvcml6b250YWwiLCJtYXJnaW5zIiwibWFyZ2luIiwiZ2V0VGhlbWUiLCJkZWZhdWx0U3R5bGVzIiwiSHRtbFJvd0lucHV0IiwiZWxlbWVudCIsIl9lbGVtZW50IiwiZm9udCIsImZvbnRTdHlsZSIsIm92ZXJmbG93IiwidGV4dENvbG9yIiwiY2VsbFBhZGRpbmciLCJjZWxsV2lkdGgiLCJtaW5DZWxsSGVpZ2h0IiwibWluQ2VsbFdpZHRoIiwibmFtZSIsInRoZW1lcyIsInN0cmlwZWQiLCJmb290IiwiYWx0ZXJuYXRlUm93IiwiZ3JpZCIsInBsYWluIiwicGFyc2VDc3MiLCJjb21tb25fMSIsInN1cHBvcnRlZEZvbnRzIiwic3R5bGUiLCJyZXN1bHQiLCJweFNjYWxlRmFjdG9yIiwiYmFja2dyb3VuZENvbG9yIiwicGFyc2VDb2xvciIsImVsZW0iLCJnZXRDb21wdXRlZFN0eWxlIiwicGFkZGluZyIsInBhcnNlUGFkZGluZyIsImJvcmRlckNvbG9yU2lkZSIsImZpbmFsU2NhbGVGYWN0b3IiLCJidHciLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlcldpZHRoIiwicGFyc2VGbG9hdCIsImJvcmRlckNvbG9yIiwiYWNjZXB0ZWQiLCJpbmRleE9mIiwidGV4dEFsaWduIiwidmVydGljYWxBbGlnbiIsInJlcyIsInBhcnNlSW50IiwiaXNOYU4iLCJwYXJzZUZvbnRTdHlsZSIsImZvbnRGYW1pbHkiLCJ0b0xvd2VyQ2FzZSIsImZvbnRXZWlnaHQiLCJzdHlsZUdldHRlciIsImNzc0NvbG9yIiwicmVhbENvbG9yIiwicmdiYSIsIm1hdGNoIiwiY29sb3IiLCJhbHBoYSIsImJnIiwicGFyZW50RWxlbWVudCIsInZhbCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJsaW5lUGFkZGluZyIsImlucHV0UGFkZGluZyIsIm4iLCJqc1BERkRvY3VtZW50IiwidXNlclN0eWxlcyIsImdldFRleHRDb2xvciIsImdldEZvbnQiLCJmb250TmFtZSIsImdldExpbmVXaWR0aCIsImdldERyYXdDb2xvciIsIl9fYXV0b1RhYmxlRG9jdW1lbnREZWZhdWx0cyIsInVuaWZ5Q29sb3IiLCJmb250T25seSIsInNldEZvbnRTdHlsZSIsImF2YWlsYWJsZUZvbnRTdHlsZXMiLCJnZXRGb250TGlzdCIsInNldEZvbnQiLCJzZXRGb250U2l6ZSIsInNldEZpbGxDb2xvciIsImFwcGx5Iiwic2V0VGV4dENvbG9yIiwic2V0RHJhd0NvbG9yIiwic2V0TGluZVdpZHRoIiwic3BsaXRUZXh0VG9TaXplIiwic2l6ZSIsIm9wdHMiLCJoZWlnaHQiLCJnZXRMYXN0QXV0b1RhYmxlIiwic2V0UGFnZSIsInBhZ2UiLCJnZXRHbG9iYWxPcHRpb25zIiwiZ2V0RG9jdW1lbnRPcHRpb25zIiwiZ2V0SGVpZ2h0IiwiZ2V0TGluZUhlaWdodCIsInBhZ2VJbmZvIiwiZ2V0Q3VycmVudFBhZ2VJbmZvIiwiZ2V0TnVtYmVyT2ZQYWdlcyIsImNzc1BhcnNlcl8xIiwiY29uZmlnXzEiLCJpbmNsdWRlSGlkZGVuSHRtbCIsInVzZUNzcyIsInRhYmxlRWxlbWVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImtleXMiLCJ0YWdOYW1lIiwicGFyc2VSb3dDb250ZW50IiwicHVzaCIsImluY2x1ZGVIaWRkZW4iLCJyZXN1bHRSb3ciLCJjZWxscyIsInN0eWxlXzEiLCJkaXNwbGF5IiwiY2VsbFN0eWxlcyIsInJvd1NwYW4iLCJjb2xTcGFuIiwicGFyc2VDZWxsQ29udGVudCIsIm9yZ0NlbGwiLCJjbG9uZU5vZGUiLCJpbm5lckhUTUwiLCJyZXBsYWNlIiwicGFydCIsInRyaW0iLCJqb2luIiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJwb2x5ZmlsbHNfMSIsImlucHV0VmFsaWRhdG9yXzEiLCJjdXJyZW50IiwiYXNzaWduIiwid2luIiwicGFyc2VTdHlsZXMiLCJob29rcyIsInBhcnNlSG9va3MiLCJwYXJzZVNldHRpbmdzIiwicGFyc2VDb250ZW50IiwiaWQiLCJ0YWJsZUlkIiwiZ0lucHV0IiwiZElucHV0IiwiY0lucHV0Iiwic3R5bGVPcHRpb25zIiwiaGVhZFN0eWxlcyIsImJvZHlTdHlsZXMiLCJmb290U3R5bGVzIiwiYWx0ZXJuYXRlUm93U3R5bGVzIiwiY29sdW1uU3R5bGVzIiwiX2xvb3BfMSIsInByb3AiLCJnbG9iYWxfMSIsImRvY3VtZW50XzEiLCJhbGxPcHRpb25zIiwiZGlkUGFyc2VDZWxsIiwid2lsbERyYXdDZWxsIiwiZGlkRHJhd0NlbGwiLCJ3aWxsRHJhd1BhZ2UiLCJkaWREcmF3UGFnZSIsImFsbE9wdGlvbnNfMSIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiX2oiLCJfayIsIl9sIiwiX20iLCJzdGFydFkiLCJnZXRTdGFydFkiLCJzaG93Rm9vdCIsInNob3dIZWFkIiwidGhlbWUiLCJob3Jpem9udGFsUGFnZUJyZWFrIiwiaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCIsInBhZ2VCcmVhayIsInJvd1BhZ2VCcmVhayIsInRhYmxlV2lkdGgiLCJob3Jpem9udGFsUGFnZUJyZWFrQmVoYXZpb3VyIiwidXNlclN0YXJ0WSIsInNmIiwiY3VycmVudFBhZ2UiLCJpc1NhbWVQYWdlQXNQcmV2aW91c1RhYmxlIiwic3RhcnRQYWdlTnVtYmVyIiwiZW5kaW5nUGFnZSIsImh0bWwiLCJoaWRkZW4iLCJodG1sQ29udGVudCIsInBhcnNlQ29sdW1ucyIsImZpcnN0Um93IiwiZmlsdGVyIiwia2V5IiwiZm9yRWFjaCIsImNvbmNhdCIsInJvd1Jlc3VsdCIsImRhdGFLZXkiLCJleHRlbmRXaWR0aCIsImFmdGVyUGFnZUNvbnRlbnQiLCJiZWZvcmVQYWdlQ29udGVudCIsImFmdGVyUGFnZUFkZCIsImRlcHJlY2F0ZWQiLCJvIiwiZGVwcmVjYXRlZE9wdGlvbiIsInN0eWxlUHJvcCIsImNoZWNrU3R5bGVzIiwicm93SGVpZ2h0IiwiY29sdW1uV2lkdGgiLCJDb2x1bW4iLCJDZWxsIiwiUm93IiwiVGFibGUiLCJIb29rRGF0YV8xIiwiZ2V0SGVhZEhlaWdodCIsImFjYyIsImdldE1heENlbGxIZWlnaHQiLCJnZXRGb290SGVpZ2h0IiwiYWxsUm93cyIsImNhbGxDZWxsSG9va3MiLCJoYW5kbGVycyIsImhhbmRsZXJzXzEiLCJoYW5kbGVyIiwiY2FsbEVuZFBhZ2VIb29rcyIsImNhbGxXaWxsRHJhd1BhZ2VIb29rcyIsInBhZ2VXaWR0aCIsIndyYXBwZWRXaWR0aCIsInRvdGFsIiwiY29sIiwicmF3IiwiaW5kZXgiLCJzcGFuc011bHRpcGxlUGFnZXMiLCJoYXNSb3dTcGFuIiwiY2FuRW50aXJlUm93Rml0IiwiZ2V0TWluaW11bVJvd0hlaWdodCIsInZQYWRkaW5nIiwib25lUm93SGVpZ2h0IiwiY29udGVudEhlaWdodCIsImNvbnRlbnRXaWR0aCIsIm1pblJlYWRhYmxlV2lkdGgiLCJtaW5XaWR0aCIsInRpdGxlIiwiZ2V0VGV4dFBvcyIsIm5ldEhlaWdodCIsIm5ldFdpZHRoIiwiZ2V0Q29udGVudEhlaWdodCIsImdldE1heEN1c3RvbUNlbGxXaWR0aCIsInRhcmdldCIsInMiLCJzMSIsInMyIiwiczMiLCJ0byIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwibW9kZWxzXzEiLCJ3aWR0aENhbGN1bGF0b3JfMSIsImpzUERGRG9jIiwiY2FsY3VsYXRlV2lkdGhzIiwiY3JlYXRlQ29sdW1ucyIsInNlY3Rpb25Sb3ciLCJnZW5lcmF0ZVNlY3Rpb25Sb3ciLCJwYXJzZVNlY3Rpb24iLCJzZWN0aW9uTmFtZSIsInNlY3Rpb25Sb3dzIiwic3R5bGVQcm9wcyIsInJvd1NwYW5zTGVmdEZvckNvbHVtbiIsInJhd1JvdyIsInJvd0luZGV4Iiwic2tpcHBlZFJvd0ZvclJvd1NwYW5zIiwiY29sU3BhbnNBZGRlZCIsImNvbHVtblNwYW5zTGVmdCIsImNvbHVtbnNfMSIsInJhd0NlbGwiLCJjZWxsSW5wdXRTdHlsZXMiLCJ0aW1lcyIsImdldFNlY3Rpb25UaXRsZSIsImhlYWRlciIsImZvb3RlciIsInRoZW1lTmFtZSIsInNlY3Rpb25TdHlsZXMiLCJvdGhlclN0eWxlcyIsImNvbFN0eWxlcyIsInJvd1N0eWxlcyIsImRlZmF1bHRTdHlsZSIsInRoZW1lU3R5bGVzIiwidGFibGVQcmludGVyXzEiLCJzZWN0aW9uc0hlaWdodCIsIm1pblRhYmxlQm90dG9tUG9zIiwidGFibGVIZWlnaHQiLCJuZXh0UGFnZSIsInByaW50VGFibGVXaXRoSG9yaXpvbnRhbFBhZ2VCcmVhayIsInByaW50Um93IiwiaXNMYXN0Um93IiwicHJpbnRGdWxsUm93IiwiYWxsQ29sdW1uc0NhbkZpdFJlc3VsdCIsImNhbGN1bGF0ZUFsbENvbHVtbnNDYW5GaXRJblBhZ2UiLCJjb2xzQW5kSW5kZXhlcyIsInByaW50SGVhZCIsInByaW50Qm9keSIsInByaW50Rm9vdCIsImxhc3RSb3dJbmRleE9mTGFzdFBhZ2VfMSIsImZpcnN0Q29sdW1uc1RvRml0UmVzdWx0IiwibGFzdFByaW50ZWRSb3dJbmRleCIsImZpcnN0Q29sdW1uc1RvRml0IiwicHJpbnRCb2R5V2l0aG91dFBhZ2VCcmVha3MiLCJtYXhOdW1iZXJPZlJvd3MiLCJzbGljZSIsInN0YXJ0Um93SW5kZXgiLCJlbmRSb3dJbmRleCIsIm1pbiIsInJlbWFpbmluZ1NwYWNlIiwiZ2V0UmVtYWluaW5nUGFnZVNwYWNlIiwiZ2V0UmVtYWluaW5nTGluZUNvdW50IiwicmVtYWluaW5nUGFnZVNwYWNlIiwicmVtYWluaW5nTGluZXMiLCJmbG9vciIsIm1vZGlmeVJvd1RvRml0IiwicmVtYWluZGVyQ2VsbCIsInJlbWFpbmluZ0xpbmVDb3VudCIsInNwbGljZSIsInJlbWFpbmRlclJvdyIsInNob3VsZFByaW50T25DdXJyZW50UGFnZSIsInBhZ2VIZWlnaHQiLCJtYXJnaW5IZWlnaHQiLCJtYXhSb3dIZWlnaHQiLCJtaW5Sb3dIZWlnaHQiLCJtaW5Sb3dGaXRzIiwicm93SGFzUm93U3BhbkNlbGwiLCJyb3dIaWdoZXJUaGFuUGFnZSIsImRyYXdDZWxsUmVjdCIsInRleHRQb3MiLCJjZWlsIiwiZ2V0RmlsbENvbG9yIiwiZHJhd0NlbGxCb3JkZXJzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJsaW5lIiwiYm90dG9tQ29udGVudEhlaWdodCIsInN1cHByZXNzRm9vdGVyIiwibmV3Q3VycmVudCIsImdldENvbHVtbnNDYW5GaXRJblBhZ2UiLCJjb25maWciLCJyZW1haW5pbmdXaWR0aCIsInJlcGVhdENvbHVtbnNNYXAiLCJNYXAiLCJjb2xJbmRleGVzIiwiZmllbGQiLCJmaW5kIiwiaXRlbSIsImhhcyIsInNldCIsImZpcnN0Iiwic3RhcnQiLCJjb2xXaWR0aCIsImxhc3RJbmRleCIsImFsbFJlc3VsdHMiLCJlbGxpcHNpemUiLCJyZXNpemVDb2x1bW5zIiwiY2FsY3VsYXRlIiwicmVzaXphYmxlQ29sdW1ucyIsImluaXRpYWxUYWJsZVdpZHRoIiwiY3VzdG9tV2lkdGgiLCJyZXNpemVXaWR0aCIsImFicyIsInJvdW5kIiwid2FybiIsImFwcGx5Q29sU3BhbnMiLCJmaXRDb250ZW50IiwiYXBwbHlSb3dTcGFucyIsImF2YWlsYWJsZVBhZ2VXaWR0aCIsImxvbmdlc3RXb3JkV2lkdGgiLCJkZWZhdWx0TWluV2lkdGgiLCJnZXRNaW5XaWR0aCIsImluaXRpYWxSZXNpemVXaWR0aCIsInN1bVdyYXBwZWRXaWR0aCIsInJhdGlvIiwic3VnZ2VzdGVkQ2hhbmdlIiwic3VnZ2VzdGVkV2lkdGgiLCJuZXdXaWR0aCIsInJvd1NwYW5DZWxscyIsImNvbFJvd1NwYW5zTGVmdCIsImFsbCIsInJlbWFpbmluZyIsImNvbFNwYW5DZWxsIiwiY29tYmluZWRDb2xTcGFuV2lkdGgiLCJjb2xTcGFuc0xlZnQiLCJjb2x1bW5JbmRleCIsInJvd1NwYW5IZWlnaHQiLCJjb3VudCIsInRleHRTcGFjZSIsInJlYWxDb250ZW50SGVpZ2h0Iiwic3RyIiwiZWxsaXBzaXplU3RyIiwicHJlY2lzaW9uIiwic3Vic3RyaW5nIiwiRXJyb3IiLCJjb2RlIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJ1bmRlZmluZWQiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX19kcmF3VGFibGUiLCJfX2NyZWF0ZVRhYmxlIiwiYXBwbHlQbHVnaW4iLCJhcHBseVBsdWdpbl8xIiwiZW51bWVyYWJsZSIsImdldCIsIm1vZGVsc18yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.js\n");

/***/ })

};
;